// Licensed to Cloudera, Inc. under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  Cloudera, Inc. licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/* parser generated by jison 0.4.17 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
import SqlParseSupport from './sqlParseSupport.js';
import importedTable from './table.js'

var genericAutocompleteParser = (function(){
  var parser = {trace: function trace () { },
    yy: {},
    symbols_: {"error":2,"DataDefinition_EDIT":3,"ALTER":4,"CURSOR":5,"AlterTable_EDIT":6,"AlterView_EDIT":7,"CREATE":8,"DatabaseDefinition_EDIT":9,"TableDefinition_EDIT":10,"ViewDefinition_EDIT":11,"DROP":12,"DropDatabaseStatement_EDIT":13,"DropTableStatement_EDIT":14,"DropViewStatement_EDIT":15,"SET":16,"TruncateTableStatement_EDIT":17,"UseStatement_EDIT":18,"DataDefinition":19,"AlterTable":20,"AlterView":21,"DatabaseDefinition":22,"RoleDefinition":23,"TableDefinition":24,"ViewDefinition":25,"DropDatabaseStatement":26,"DropRoleStatement":27,"DropTableStatement":28,"DropViewStatement":29,"ALL":30,"SetOption":31,"=":32,"SetValue":33,"TruncateTableStatement":34,"UseStatement":35,"AlterTableLeftSide":36,"PartitionSpec":37,"AlterTableLeftSide_EDIT":38,"TABLE":39,"SchemaQualifiedTableIdentifier":40,"SchemaQualifiedTableIdentifier_EDIT":41,"AlterViewLeftSide":42,"AS":43,"QuerySpecification":44,"AlterViewLeftSide_EDIT":45,"QuerySpecification_EDIT":46,"VIEW":47,"OptionalComment":48,"Comment":49,"COMMENT":50,"QuotedValue":51,"OptionalComment_INVALID":52,"Comment_INVALID":53,"SINGLE_QUOTE":54,"DOUBLE_QUOTE":55,"VALUE":56,"DatabaseOrSchema":57,"OptionalIfNotExists":58,"RegularIdentifier":59,"DatabaseDefinitionOptionals":60,"OptionalIfNotExists_EDIT":61,"DatabaseDefinitionOptionals_EDIT":62,"ROLE":63,"TableDefinitionRightPart":64,"TableDefinitionRightPart_EDIT":65,"TableIdentifierAndOptionalColumnSpecification":66,"OptionalPartitionedBy":67,"OptionalAsSelectStatement":68,"TableIdentifierAndOptionalColumnSpecification_EDIT":69,"PartitionedBy_EDIT":70,"OptionalAsSelectStatement_EDIT":71,"SchemaQualifiedIdentifier":72,"OptionalColumnSpecificationsOrLike":73,"OptionalColumnSpecificationsOrLike_EDIT":74,"SchemaQualifiedIdentifier_EDIT":75,"ParenthesizedColumnSpecificationList":76,"LIKE":77,"ParenthesizedColumnSpecificationList_EDIT":78,"(":79,"ColumnSpecificationList":80,")":81,"ColumnSpecificationList_EDIT":82,"RightParenthesisOrError":83,"ColumnSpecification":84,",":85,"ColumnSpecification_EDIT":86,"ColumnIdentifier":87,"ColumnDataType":88,"OptionalColumnOptions":89,"ColumnDataType_EDIT":90,"ColumnOptions_EDIT":91,"ColumnOptions":92,"ColumnOption":93,"ColumnOption_EDIT":94,"NOT":95,"NULL":96,"PrimitiveType":97,"ArrayType":98,"MapType":99,"StructType":100,"ArrayType_INVALID":101,"MapType_INVALID":102,"StructType_INVALID":103,"ArrayType_EDIT":104,"MapType_EDIT":105,"StructType_EDIT":106,"ARRAY":107,"<":108,">":109,"AnyCursor":110,"GreaterThanOrError":111,"MAP":112,"STRUCT":113,"StructDefinitionList":114,"StructDefinitionList_EDIT":115,"StructDefinition":116,"StructDefinition_EDIT":117,"Commas":118,"RegularOrBacktickedIdentifier":119,":":120,"ColumnDataTypeList":121,"ColumnDataTypeList_EDIT":122,"ColumnDataTypeListInner_EDIT":123,"PartitionedBy":124,"PARTITION":125,"BY":126,"RangeClause":127,"RangeClause_EDIT":128,"RANGE":129,"ParenthesizedColumnList":130,"ParenthesizedPartitionValuesList":131,"ParenthesizedColumnList_EDIT":132,"ParenthesizedPartitionValuesList_EDIT":133,"PartitionValueList":134,"PartitionValueList_EDIT":135,"PartitionValue":136,"PartitionValue_EDIT":137,"ValueExpression":138,"LessThanOrEqualTo":139,"VALUES":140,"ValueExpression_EDIT":141,"COMPARISON_OPERATOR":142,"CommitLocations":143,"OptionalParenthesizedViewColumnList":144,"ParenthesizedViewColumnList_EDIT":145,"ParenthesizedViewColumnList":146,"ViewColumnList":147,"ViewColumnList_EDIT":148,"ColumnReference":149,"OptionalIfExists":150,"OptionalCascade":151,"OptionalIfExists_EDIT":152,"OptionalPurge":153,"PURGE":154,"DataManipulation":155,"InsertStatement":156,"UpdateStatement":157,"InsertValuesStatement":158,"DataManipulation_EDIT":159,"InsertValuesStatement_EDIT":160,"UpdateStatement_EDIT":161,"INSERT":162,"INTO":163,"OptionalTable":164,"InsertValuesList":165,"ParenthesizedRowValuesList":166,"InValueList":167,"CommonTableExpression":168,"SelectStatement":169,"OptionalUnions":170,"SelectStatement_EDIT":171,"OptionalUnions_EDIT":172,"CommonTableExpression_EDIT":173,"WITH":174,"WithQueries":175,"WithQueries_EDIT":176,"WithQuery":177,"WithQuery_EDIT":178,"TableSubQueryInner":179,"TableSubQueryInner_EDIT":180,"FromClause":181,"FROM":182,"TableReferenceList":183,"FromClause_EDIT":184,"TableReferenceList_EDIT":185,"TableReference":186,"TableReference_EDIT":187,"OptionalGroupByClause":188,"GroupByClause":189,"GROUP":190,"GroupByColumnList":191,"GroupByClause_EDIT":192,"GroupByColumnList_EDIT":193,"ColumnGroupingSets":194,"ColumnGroupingSets_EDIT":195,"ColumnGroupingSet_EDIT":196,"ColumnReference_EDIT":197,"GroupByColumnListPartTwo_EDIT":198,"OptionalHavingClause":199,"HavingClause":200,"HAVING":201,"HavingClause_EDIT":202,"OptionalJoins":203,"Joins":204,"Joins_INVALID":205,"JoinType":206,"TablePrimary":207,"OptionalJoinCondition":208,"Join_EDIT":209,"JoinType_EDIT":210,"TablePrimary_EDIT":211,"JoinCondition_EDIT":212,"Joins_EDIT":213,"CROSS":214,"JOIN":215,"FULL":216,"OUTER":217,"INNER":218,"LEFT":219,"SEMI":220,"RIGHT":221,"ON":222,"UsingColList":223,"OptionalLimitClause":224,"LimitClause":225,"LIMIT":226,"UnsignedNumericLiteral":227,"VARIABLE_REFERENCE":228,"LimitClause_EDIT":229,"OptionalOrderByClause":230,"OrderByClause":231,"ORDER":232,"OrderByColumnList":233,"OrderByClause_EDIT":234,"OrderByColumnList_EDIT":235,"OrderByIdentifier":236,"OrderByIdentifier_EDIT":237,"OptionalAscOrDesc":238,"ASC":239,"DESC":240,"SELECT":241,"OptionalAllOrDistinct":242,"SelectList":243,"TableExpression":244,"SelectList_ERROR":245,"TableExpression_ERROR":246,"SelectList_EDIT":247,"TableExpression_EDIT":248,"SelectList_ERROR_EDIT":249,"DISTINCT":250,"OptionalSelectConditions":251,"OptionalSelectConditions_EDIT":252,"SelectSpecification":253,"SelectSpecification_EDIT":254,"OptionalCorrelationName":255,"*":256,"OptionalCorrelationName_EDIT":257,"OptionalWhereClause":258,"WhereClause_EDIT":259,"WhereClause":260,"Unions":261,"Unions_EDIT":262,"UnionClause":263,"UnionClause_EDIT":264,"UNION":265,"NewStatement":266,"WHERE":267,"SearchCondition":268,"SearchCondition_EDIT":269,".":270,"SignedInteger":271,"TRUE":272,"FALSE":273,"TRUNCATE":274,"OptionalPartitionSpec":275,"UserDefinedFunction":276,"AggregateFunction":277,"OptionalOverClause":278,"AnalyticFunction":279,"OverClause":280,"CastFunction":281,"UserDefinedFunction_EDIT":282,"AggregateFunction_EDIT":283,"OptionalOverClause_EDIT":284,"AnalyticFunction_EDIT":285,"OverClause_EDIT":286,"CastFunction_EDIT":287,"OtherAggregateFunction":288,"CountFunction":289,"SumFunction":290,"OtherAggregateFunction_EDIT":291,"CountFunction_EDIT":292,"SumFunction_EDIT":293,"OtherAggregateFunction_Type":294,"UdfArgumentList":295,"UdfArgumentList_EDIT":296,"AVG":297,"MAX":298,"MIN":299,"STDDEV_POP":300,"STDDEV_SAMP":301,"VAR_POP":302,"VAR_SAMP":303,"VARIANCE":304,"COUNT":305,"SUM":306,"ANALYTIC":307,"ArbitraryFunctionName":308,"IF":309,"CAST":310,"NonParenthesizedValueExpressionPrimary":311,"ColumnOrArbitraryFunctionRef":312,"ArbitraryFunctionRightPart":313,"UnsignedValueSpecification":314,"NonParenthesizedValueExpressionPrimary_EDIT":315,"ArbitraryFunctionRightPart_EDIT":316,"UnsignedValueSpecification_EDIT":317,"ColumnOrArbitraryFunctionRef_EDIT":318,"ArbitraryFunction":319,"ArbitraryFunction_EDIT":320,"OVER":321,"WindowExpression":322,"WindowExpression_EDIT":323,"UPDATE":324,"TargetTable":325,"SetClauseList":326,"OptionalFromJoinedTable":327,"TargetTable_EDIT":328,"SetClauseList_EDIT":329,"FromJoinedTable_EDIT":330,"TableName":331,"TableName_EDIT":332,"LocalOrSchemaQualifiedName":333,"LocalOrSchemaQualifiedName_EDIT":334,"SetClause":335,"SetClause_EDIT":336,"SetTarget":337,"UpdateSource":338,"UpdateSource_EDIT":339,"USE":340,"SqlStatements":341,"NonStartingToken":342,"SqlStatement":343,";":344,"SqlStatement_EDIT":345,"SetSpecification_EDIT":346,"ErrorList":347,"Errors":348,"SetSpecification":349,"SqlSyntax":350,"EOF":351,"SqlAutocomplete":352,"SqlStatements_EDIT":353,"NonReservedKeyword":354,"OPTION":355,"REGULAR_IDENTIFIER":356,"!":357,"-":358,"[":359,"]":360,"~":361,"AND":362,"ARITHMETIC_OPERATOR":363,"BACKTICK":364,"BETWEEN":365,"BIGINT":366,"BOOLEAN":367,"CASE":368,"CHAR":369,"CURRENT":370,"DATABASE":371,"DECIMAL":372,"DOUBLE":373,"ELSE":374,"END":375,"EXISTS":376,"FLOAT":377,"FOLLOWING":378,"HDFS_START_QUOTE":379,"IN":380,"INT":381,"IS":382,"OR":383,"PRECEDING":384,"REGEXP":385,"ILIKE":386,"ROW":387,"ROWS":388,"SCHEMA":389,"SMALLINT":390,"STRING":391,"THEN":392,"TIMESTAMP":393,"TINYINT":394,"UNSIGNED_INTEGER":395,"UNSIGNED_INTEGER_E":396,"VARCHAR":397,"WHEN":398,"PARTIAL_CURSOR":399,"FromOrIn":400,"SingleQuotedValue":401,"SingleQuotedValue_EDIT":402,"PARTIAL_VALUE":403,"DoubleQuotedValue":404,"DoubleQuotedValue_EDIT":405,"QuotedValue_EDIT":406,"OptionalFromDatabase":407,"DatabaseIdentifier":408,"OptionalFromDatabase_EDIT":409,"DatabaseIdentifier_EDIT":410,"CASCADE":411,"OptionalInDatabase":412,"OptionalPartitionSpec_EDIT":413,"PartitionSpec_EDIT":414,"PartitionSpecList":415,"PartitionSpecList_EDIT":416,"RangePartitionSpec":417,"RangePartitionComparisonOperator":418,"RangePartitionSpec_EDIT":419,"ConfigurationName":420,"PartialBacktickedOrAnyCursor":421,"PartialBacktickedIdentifier":422,"PartialBacktickedOrCursor":423,"PartialBacktickedOrPartialCursor":424,"OptionalParenthesizedColumnList":425,"OptionalParenthesizedColumnList_EDIT":426,"ColumnList":427,"ColumnList_EDIT":428,"ParenthesizedSimpleValueList":429,"SimpleValueList":430,"PartitionExpression":431,"PartitionExpression_EDIT":432,"RegularOrBackTickedSchemaQualifiedName":433,"RegularOrBackTickedSchemaQualifiedName_EDIT":434,"BasicIdentifierChain":435,"BasicIdentifierChain_EDIT":436,"DerivedColumnChain":437,"DerivedColumnChain_EDIT":438,"PartialBacktickedIdentifierOrPartialCursor":439,"OptionalTypeLength":440,"OptionalTypePrecision":441,"OptionalNot":442,"TableSubQuery":443,"ValueExpressionList":444,"BETWEEN_AND":445,"LikeRightPart":446,"CaseRightPart":447,"TableSubQuery_EDIT":448,"ValueExpressionInSecondPart_EDIT":449,"LikeRightPart_EDIT":450,"CaseRightPart_EDIT":451,"EndOrError":452,"ValueExpressionList_EDIT":453,"+":454,"UnsignedLiteral":455,"UnsignedLiteral_EDIT":456,"GeneralLiteral":457,"GeneralLiteral_EDIT":458,"ExactNumericLiteral":459,"ApproximateNumericLiteral":460,"TruthValue":461,"TablePrimaryOrJoinedTable":462,"TablePrimaryOrJoinedTable_EDIT":463,"JoinedTable":464,"JoinedTable_EDIT":465,"TableOrQueryName":466,"DerivedTable":467,"TableOrQueryName_EDIT":468,"DerivedTable_EDIT":469,"OptionalOnColumn":470,"OptionalOnColumn_EDIT":471,"PushQueryState":472,"PopQueryState":473,"SubQuery":474,"SubQuery_EDIT":475,"QueryExpression":476,"QueryExpression_EDIT":477,"QueryExpressionBody":478,"QueryExpressionBody_EDIT":479,"NonJoinQueryExpression":480,"NonJoinQueryExpression_EDIT":481,"NonJoinQueryTerm":482,"NonJoinQueryTerm_EDIT":483,"NonJoinQueryPrimary":484,"NonJoinQueryPrimary_EDIT":485,"SimpleTable":486,"SimpleTable_EDIT":487,"OptionalPartitionBy":488,"OptionalOrderByAndWindow":489,"PartitionBy_EDIT":490,"OptionalOrderByAndWindow_EDIT":491,"PartitionBy":492,"OptionalWindowSpec":493,"WindowSpec_EDIT":494,"WindowSpec":495,"RowsOrRange":496,"PopLexerState":497,"OptionalCurrentOrPreceding":498,"OptionalAndFollowing":499,"UNBOUNDED":500,"OptionalCurrentOrPreceding_EDIT":501,"OptionalAndFollowing_EDIT":502,"PushHdfsLexerState":503,"HdfsPath":504,"HDFS_PATH":505,"HDFS_END_QUOTE":506,"HdfsPath_EDIT":507,"IntegerOrUnbounded":508,"CaseWhenThenList":509,"CaseWhenThenList_EDIT":510,"CaseWhenThenListPartTwo":511,"CaseWhenThenListPartTwo_EDIT":512,"$accept":0,"$end":1},
    terminals_: {2:"error",4:"ALTER",5:"CURSOR",8:"CREATE",12:"DROP",16:"SET",30:"ALL",32:"=",39:"TABLE",43:"AS",47:"VIEW",50:"COMMENT",54:"SINGLE_QUOTE",55:"DOUBLE_QUOTE",56:"VALUE",63:"ROLE",77:"LIKE",79:"(",81:")",85:",",95:"NOT",96:"NULL",107:"ARRAY",108:"<",109:">",112:"MAP",113:"STRUCT",120:":",125:"PARTITION",126:"BY",129:"RANGE",140:"VALUES",142:"COMPARISON_OPERATOR",154:"PURGE",162:"INSERT",163:"INTO",174:"WITH",182:"FROM",190:"GROUP",201:"HAVING",214:"CROSS",215:"JOIN",216:"FULL",217:"OUTER",218:"INNER",219:"LEFT",220:"SEMI",221:"RIGHT",222:"ON",226:"LIMIT",228:"VARIABLE_REFERENCE",232:"ORDER",239:"ASC",240:"DESC",241:"SELECT",246:"TableExpression_ERROR",250:"DISTINCT",256:"*",265:"UNION",267:"WHERE",270:".",272:"TRUE",273:"FALSE",274:"TRUNCATE",297:"AVG",298:"MAX",299:"MIN",300:"STDDEV_POP",301:"STDDEV_SAMP",302:"VAR_POP",303:"VAR_SAMP",304:"VARIANCE",305:"COUNT",306:"SUM",307:"ANALYTIC",309:"IF",310:"CAST",321:"OVER",324:"UPDATE",340:"USE",344:";",346:"SetSpecification_EDIT",348:"Errors",351:"EOF",355:"OPTION",356:"REGULAR_IDENTIFIER",357:"!",358:"-",359:"[",360:"]",361:"~",362:"AND",363:"ARITHMETIC_OPERATOR",364:"BACKTICK",365:"BETWEEN",366:"BIGINT",367:"BOOLEAN",368:"CASE",369:"CHAR",370:"CURRENT",371:"DATABASE",372:"DECIMAL",373:"DOUBLE",374:"ELSE",375:"END",376:"EXISTS",377:"FLOAT",378:"FOLLOWING",379:"HDFS_START_QUOTE",380:"IN",381:"INT",382:"IS",383:"OR",384:"PRECEDING",385:"REGEXP",386:"ILIKE",387:"ROW",388:"ROWS",389:"SCHEMA",390:"SMALLINT",391:"STRING",392:"THEN",393:"TIMESTAMP",394:"TINYINT",395:"UNSIGNED_INTEGER",396:"UNSIGNED_INTEGER_E",397:"VARCHAR",398:"WHEN",399:"PARTIAL_CURSOR",403:"PARTIAL_VALUE",411:"CASCADE",445:"BETWEEN_AND",454:"+",500:"UNBOUNDED",505:"HDFS_PATH",506:"HDFS_END_QUOTE"},
    productions_: [0,[3,2],[3,1],[3,1],[3,2],[3,1],[3,1],[3,1],[3,2],[3,1],[3,1],[3,1],[3,2],[3,1],[3,1],[19,1],[19,1],[19,1],[19,1],[19,1],[19,1],[19,1],[19,1],[19,1],[19,1],[19,2],[19,4],[19,1],[19,1],[20,2],[6,1],[6,2],[6,2],[6,3],[36,3],[38,3],[38,3],[21,3],[7,1],[7,2],[7,3],[7,3],[7,3],[42,3],[45,3],[45,3],[48,0],[48,1],[49,2],[52,1],[53,2],[53,2],[53,3],[53,3],[22,3],[22,5],[9,4],[9,3],[9,5],[9,4],[9,6],[9,6],[60,1],[62,1],[23,3],[24,4],[10,4],[10,4],[10,3],[64,3],[65,3],[65,3],[65,3],[65,3],[66,2],[69,2],[69,2],[73,0],[73,1],[73,2],[74,1],[74,2],[74,2],[76,3],[78,3],[80,1],[80,3],[82,1],[82,3],[82,3],[82,5],[82,2],[82,4],[82,4],[82,6],[84,3],[86,3],[86,3],[86,3],[89,0],[89,1],[92,1],[92,2],[91,1],[91,2],[91,2],[91,3],[93,2],[93,1],[93,1],[94,2],[88,1],[88,1],[88,1],[88,1],[88,1],[88,1],[88,1],[90,1],[90,1],[90,1],[98,4],[101,3],[104,4],[104,4],[99,6],[102,3],[105,6],[105,4],[105,6],[105,5],[100,4],[103,3],[106,4],[114,1],[114,3],[115,1],[115,2],[115,3],[115,3],[115,5],[116,4],[117,5],[117,4],[117,4],[117,4],[117,3],[117,3],[121,1],[121,3],[122,1],[122,2],[122,3],[122,3],[122,5],[123,2],[123,2],[123,1],[123,1],[111,1],[111,1],[67,0],[67,1],[124,3],[70,2],[70,3],[70,3],[127,3],[128,2],[128,2],[128,3],[128,3],[128,3],[131,3],[133,3],[133,3],[134,1],[134,3],[135,1],[135,3],[135,5],[135,3],[135,5],[136,6],[136,4],[136,4],[137,2],[137,2],[137,3],[137,4],[137,4],[137,5],[137,6],[137,6],[137,3],[137,4],[137,4],[139,1],[139,1],[68,0],[68,3],[71,3],[71,3],[143,0],[25,8],[11,4],[11,9],[11,3],[11,6],[11,7],[11,8],[11,8],[11,8],[144,0],[144,1],[146,3],[145,3],[147,2],[147,4],[148,3],[148,5],[148,5],[148,7],[26,5],[13,3],[13,3],[13,4],[13,5],[13,5],[13,6],[27,3],[28,5],[14,3],[14,4],[14,5],[14,5],[14,6],[153,0],[153,1],[29,4],[15,4],[15,5],[15,3],[15,4],[15,4],[155,1],[155,1],[156,1],[159,1],[159,1],[158,6],[160,2],[160,4],[160,4],[160,5],[160,6],[165,1],[165,3],[166,3],[164,0],[164,1],[44,3],[44,5],[44,2],[46,4],[46,3],[46,3],[46,1],[46,4],[46,3],[46,2],[46,2],[168,2],[173,2],[175,1],[175,3],[176,1],[176,3],[176,3],[176,5],[177,5],[178,2],[178,5],[178,5],[181,2],[184,2],[184,2],[183,1],[183,3],[185,1],[185,3],[185,3],[185,5],[185,3],[188,0],[188,1],[189,3],[192,3],[192,3],[192,2],[194,0],[194,1],[194,3],[194,3],[195,1],[195,3],[195,3],[195,5],[195,3],[196,1],[196,1],[191,1],[191,3],[193,1],[193,2],[193,3],[193,3],[193,3],[193,4],[193,5],[198,1],[198,2],[198,1],[199,0],[199,1],[200,2],[202,2],[202,2],[203,0],[203,1],[203,1],[204,3],[204,4],[205,1],[205,2],[209,3],[209,1],[209,3],[209,3],[209,3],[213,1],[213,2],[213,2],[213,3],[206,2],[206,2],[206,3],[206,2],[206,1],[206,3],[206,2],[206,3],[206,3],[206,2],[206,3],[206,2],[206,3],[206,3],[206,2],[210,2],[210,3],[210,3],[210,2],[210,3],[210,3],[210,3],[210,3],[210,2],[210,3],[210,3],[210,3],[210,3],[210,2],[210,3],[210,3],[210,3],[208,0],[208,2],[223,1],[223,3],[212,2],[212,2],[224,0],[224,1],[225,2],[225,4],[225,2],[225,4],[229,2],[230,0],[230,1],[231,3],[234,3],[234,2],[233,1],[233,3],[235,1],[235,2],[235,3],[235,4],[235,5],[236,2],[237,2],[237,2],[238,0],[238,1],[238,1],[169,3],[169,4],[169,4],[169,4],[171,3],[171,3],[171,4],[171,4],[171,4],[171,5],[171,6],[171,4],[171,4],[171,4],[242,0],[242,1],[242,1],[244,2],[248,2],[248,4],[248,3],[243,1],[243,3],[247,1],[247,2],[247,3],[247,3],[247,3],[247,4],[247,3],[247,3],[247,4],[247,4],[247,4],[247,5],[247,5],[253,2],[253,1],[254,2],[254,3],[254,2],[251,5],[252,5],[252,5],[252,5],[252,5],[252,5],[252,6],[252,6],[252,6],[252,6],[252,6],[252,7],[252,7],[252,7],[252,7],[252,6],[252,6],[252,6],[252,6],[252,6],[252,6],[252,6],[252,6],[252,6],[252,6],[170,0],[170,1],[172,1],[261,1],[261,2],[262,1],[262,2],[262,2],[262,3],[263,4],[264,3],[264,4],[264,4],[258,0],[258,1],[260,2],[259,2],[259,2],[268,1],[269,1],[31,1],[31,3],[33,1],[33,1],[33,2],[33,1],[33,1],[33,1],[33,1],[34,4],[17,2],[17,4],[17,3],[17,4],[17,5],[17,5],[17,5],[276,2],[276,2],[276,1],[282,1],[282,2],[282,1],[282,2],[282,2],[282,2],[282,1],[277,1],[277,1],[277,1],[283,1],[283,1],[283,1],[288,4],[288,5],[291,5],[291,6],[291,5],[294,1],[294,1],[294,1],[294,1],[294,1],[294,1],[294,1],[294,1],[289,4],[289,3],[289,5],[292,5],[292,6],[292,5],[290,5],[290,3],[293,5],[293,6],[293,5],[279,3],[279,4],[285,4],[285,5],[285,4],[308,1],[308,1],[308,1],[308,1],[281,6],[281,3],[287,6],[287,5],[287,4],[287,6],[287,5],[287,4],[287,6],[287,5],[287,6],[287,5],[311,2],[311,2],[311,1],[311,1],[311,1],[311,1],[315,2],[315,2],[315,1],[315,1],[315,1],[319,2],[319,2],[320,2],[320,2],[313,2],[313,3],[316,3],[316,4],[316,3],[295,1],[295,3],[296,1],[296,3],[296,3],[296,5],[296,3],[296,5],[296,4],[296,3],[296,2],[296,2],[296,4],[278,0],[278,1],[284,1],[280,2],[280,2],[286,2],[157,6],[161,6],[161,6],[161,6],[161,6],[161,7],[161,3],[161,2],[161,2],[161,2],[325,1],[328,1],[331,1],[332,1],[326,1],[326,3],[329,1],[329,3],[329,3],[329,5],[335,3],[336,3],[336,2],[336,1],[337,1],[338,1],[339,1],[327,0],[327,2],[330,2],[330,2],[35,2],[18,2],[341,1],[341,2],[341,0],[341,1],[341,4],[345,2],[345,1],[345,2],[345,1],[345,1],[345,1],[345,1],[245,1],[245,3],[245,5],[245,3],[245,5],[249,3],[249,5],[249,7],[249,3],[249,5],[249,7],[349,4],[347,1],[347,3],[350,3],[352,3],[352,3],[266,0],[353,1],[353,4],[353,4],[353,7],[343,1],[343,1],[343,1],[354,1],[354,1],[354,1],[59,1],[59,1],[59,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[342,1],[118,1],[118,2],[110,1],[110,1],[400,1],[400,1],[57,1],[57,1],[401,3],[401,2],[402,2],[404,3],[404,2],[405,2],[51,1],[51,1],[406,1],[406,1],[407,0],[407,2],[409,2],[151,0],[151,1],[150,0],[150,2],[152,2],[58,0],[58,3],[61,2],[61,3],[412,0],[412,2],[412,2],[275,0],[275,1],[413,1],[37,4],[414,4],[417,5],[419,2],[419,3],[419,4],[419,5],[419,5],[419,5],[418,1],[418,1],[418,1],[418,1],[420,1],[420,1],[421,1],[421,1],[423,1],[423,1],[424,1],[424,1],[422,2],[83,1],[83,1],[425,0],[425,1],[426,1],[130,3],[132,3],[132,3],[427,1],[427,3],[428,3],[428,5],[429,3],[430,1],[430,3],[40,1],[40,3],[41,1],[41,3],[41,3],[72,1],[72,3],[75,1],[75,3],[75,3],[408,1],[410,1],[415,1],[415,3],[416,1],[416,3],[416,3],[416,5],[431,3],[432,3],[432,3],[432,3],[432,1],[119,1],[119,3],[119,2],[433,1],[433,3],[434,1],[434,3],[333,1],[333,2],[334,1],[334,2],[149,1],[149,3],[197,1],[435,1],[435,3],[436,3],[436,5],[437,1],[437,3],[438,1],[438,3],[438,5],[438,3],[87,1],[439,1],[439,1],[97,1],[97,1],[97,2],[97,2],[97,1],[97,1],[97,1],[97,1],[97,1],[97,1],[97,1],[97,2],[440,0],[440,3],[441,0],[441,3],[441,5],[138,1],[138,2],[138,2],[138,2],[138,2],[138,4],[138,4],[138,4],[138,6],[138,2],[138,3],[138,3],[138,3],[138,3],[138,3],[138,6],[138,6],[138,5],[138,5],[138,6],[138,5],[138,3],[138,3],[138,3],[138,3],[138,3],[138,2],[138,3],[138,2],[138,3],[141,1],[141,3],[141,2],[141,2],[141,2],[141,2],[141,2],[141,2],[141,2],[141,2],[141,3],[141,4],[141,5],[141,4],[141,4],[141,4],[141,6],[141,6],[141,2],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,4],[141,3],[141,6],[141,6],[141,5],[141,5],[141,6],[141,6],[141,6],[141,6],[141,5],[141,4],[141,5],[141,5],[141,5],[141,5],[141,4],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,3],[141,2],[141,3],[141,2],[141,3],[141,2],[141,3],[141,2],[141,3],[141,3],[141,4],[141,3],[141,3],[141,3],[444,1],[444,3],[453,1],[453,3],[453,3],[453,5],[453,3],[453,5],[453,4],[453,3],[453,2],[453,2],[453,4],[167,1],[167,3],[312,1],[312,3],[318,1],[271,1],[271,2],[271,2],[314,1],[317,1],[455,1],[455,1],[456,1],[227,1],[227,1],[459,1],[459,2],[459,3],[459,2],[460,2],[460,3],[460,4],[457,1],[457,1],[457,1],[458,1],[458,1],[461,1],[461,1],[442,0],[442,1],[186,1],[187,1],[462,1],[462,1],[463,1],[463,1],[464,2],[465,2],[465,2],[207,2],[207,2],[211,2],[211,2],[211,2],[466,1],[468,1],[467,1],[469,1],[470,0],[470,2],[471,2],[471,2],[472,0],[473,0],[443,3],[443,4],[448,3],[448,3],[179,2],[180,3],[474,1],[475,1],[476,1],[477,1],[478,1],[479,1],[480,1],[481,1],[482,1],[483,1],[484,1],[485,1],[486,1],[487,1],[255,0],[255,1],[255,1],[255,2],[255,2],[257,1],[257,1],[257,2],[257,2],[257,2],[322,4],[323,4],[323,4],[323,5],[323,7],[488,0],[488,1],[492,3],[490,2],[490,3],[490,3],[489,0],[489,2],[491,1],[491,3],[491,2],[493,0],[493,1],[495,5],[495,5],[494,2],[494,6],[494,5],[494,5],[494,5],[494,4],[497,0],[503,0],[504,3],[507,5],[507,4],[507,3],[507,3],[507,2],[496,1],[496,1],[498,0],[498,2],[498,2],[501,2],[501,2],[499,0],[499,3],[499,3],[502,2],[502,3],[502,3],[508,1],[508,1],[449,3],[449,3],[449,3],[446,2],[446,2],[446,2],[450,2],[450,2],[450,2],[450,2],[450,2],[450,2],[447,2],[447,4],[451,2],[451,4],[451,4],[451,3],[451,4],[451,3],[451,4],[451,4],[451,3],[451,4],[451,3],[452,1],[452,1],[509,1],[509,2],[510,1],[510,2],[510,3],[510,3],[510,2],[511,4],[512,2],[512,3],[512,4],[512,4],[512,3],[512,3],[512,4],[512,2],[512,3],[512,2],[512,3],[512,3],[512,4],[512,3],[512,4],[512,4],[512,5],[512,4],[512,3]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
      /* this == yyval */

      var $0 = $$.length - 1;
      switch (yystate) {
        case 1:

          parser.suggestKeywords(['TABLE', 'VIEW']);

          break;
        case 4: case 8:

          parser.suggestKeywords(['DATABASE', 'ROLE', 'SCHEMA', 'TABLE', 'VIEW']);

          break;
        case 12:

          parser.suggestSetOptions();

          break;
        case 34: case 43: case 239: case 243: case 502: case 622:

          parser.addTablePrimary($$[$0]);

          break;
        case 35: case 234:

          if (parser.yy.result.suggestTables) {
            parser.yy.result.suggestTables.onlyTables = true;
          }

          break;
        case 36:

          parser.suggestTables({ onlyTables: true });
          parser.suggestDatabases({ appendDot: true });

          break;
        case 39: case 281:

          parser.suggestKeywords(['AS']);

          break;
        case 41: case 201: case 210: case 282: case 650: case 1122:

          parser.suggestKeywords(['SELECT']);

          break;
        case 44: case 244:

          if (parser.yy.result.suggestTables) {
            parser.yy.result.suggestTables.onlyViews = true;
          }

          break;
        case 45:

          parser.suggestTables({ onlyViews: true });
          parser.suggestDatabases({ appendDot: true });

          break;
        case 55:

          parser.addNewDatabaseLocation(_$[$0-1], [{ name: $$[$0-1] }]);

          break;
        case 56: case 67:

          if (!$$[$0-1]) {
            parser.suggestKeywords(['IF NOT EXISTS']);
          }

          break;
        case 58:

          if (!$$[$0-2]) {
            parser.suggestKeywords(['IF NOT EXISTS']);
          }
          parser.addNewDatabaseLocation(_$[$0], [{ name: $$[$0] }]);

          break;
        case 59:

          parser.addNewDatabaseLocation(_$[$0], [{ name: $$[$0] }]);

          break;
        case 60:

          parser.addNewDatabaseLocation(_$[$0-2], [{ name: $$[$0-2] }]);

          break;
        case 62:

          if (!$$[$0]) {
            parser.suggestKeywords(['COMMENT']);
          }

          break;
        case 73:

          var keywords = [];
          if (!$$[$0-2] && !$$[$0-1]) {
            keywords.push({ value: 'LIKE', weight: 1 });
          } else {
            if (!$$[$0-1]) {
              keywords.push({ value: 'PARTITIONED BY', weight: 12 });
            }
            keywords.push({ value: 'AS', weight: 1 });
          }

          if (keywords.length > 0) {
            parser.suggestKeywords(keywords);
          }

          break;
        case 74:

          parser.addNewTableLocation(_$[$0-1], $$[$0-1], $$[$0]);
          this.$ = $$[$0];

          break;
        case 79:
          this.$ = [];
          break;
        case 81: case 619: case 639: case 869:

          parser.suggestTables();
          parser.suggestDatabases({ appendDot: true });

          break;
        case 83: case 219: case 221: case 263: case 440: case 587: case 590: case 802: case 805: case 891: case 944: case 1119:
          this.$ = $$[$0-1];
          break;
        case 85: case 274:
          this.$ = [$$[$0]];
          break;
        case 86:
          this.$ = $$[$0-2].concat($$[$0]);
          break;
        case 91: case 93:

          parser.checkForKeywords($$[$0-1]);

          break;
        case 92: case 94:

          parser.checkForKeywords($$[$0-3]);

          break;
        case 95:

          this.$ = $$[$0-2];
          this.$.type = $$[$0-1];
          var keywords = [];
          if (!$$[$0]['comment']) {
            keywords.push('COMMENT');
          }
          if (keywords.length > 0) {
            this.$.suggestKeywords = keywords;
          }

          break;
        case 96: case 123: case 129: case 130: case 143: case 146: case 155: case 157:

          parser.suggestKeywords(parser.getColumnDataTypeKeywords());

          break;
        case 99:
          this.$ = {};
          break;
        case 101:

          this.$ = {};
          this.$[$$[$0]] = true;

          break;
        case 102:

          $$[$0-1][$$[$0]] = true;

          break;
        case 107: case 108:
          this.$ = 'null';
          break;
        case 109:
          this.$ = 'comment';
          break;
        case 110:

          parser.suggestKeywords(['NULL']);

          break;
        case 128:

          parser.suggestKeywords(parser.getTypeKeywords());

          break;
        case 142: case 145:

          parser.suggestKeywords(['COMMENT']);

          break;
        case 164: case 1157:

          parser.suggestKeywords(['BY']);

          break;
        case 165:

          parser.suggestKeywords(['RANGE']);

          break;
        case 174: case 179: case 180:

          parser.suggestKeywords(['PARTITION']);

          break;
        case 186:

          parser.suggestKeywords(['VALUE', 'VALUES']);

          break;
        case 187:

          if ($$[$0].endsWithLessThanOrEqual) {
            parser.suggestKeywords(['VALUES']);
          }

          break;
        case 188: case 191: case 194:

          parser.suggestKeywords(['<', '<=']);

          break;
        case 189: case 834: case 837:

          parser.suggestKeywords(['VALUES']);

          break;
        case 192: case 195:

          parser.suggestFunctions();

          break;
        case 203:

          parser.commitLocations();

          break;
        case 205:

          if (!$$[$0-1]) {
            parser.suggestKeywords(['IF NOT EXISTS']);
          }
          parser.suggestDatabases({ appendDot: true });

          break;
        case 206:

          if (!$$[$0-6]) {
            parser.suggestKeywords(['IF NOT EXISTS']);
          }

          break;
        case 209:

          var keywords = [{value: 'AS', weight: 1 }];
          if (!$$[$0-1]) {
            keywords.push({ value: 'COMMENT', weight: 3 });
          }
          parser.suggestKeywords(keywords);

          break;
        case 216:

          if (!$$[$0-1]) {
            parser.suggestKeywords(['COMMENT']);
          }

          break;
        case 220: case 222:
          this.$ = $$[$0-3];
          break;
        case 226:

          if (!$$[$0-1]) {
            parser.suggestKeywords(['IF EXISTS']);
          }
          parser.suggestDatabases();

          break;
        case 227:

          parser.suggestKeywords(['CASCADE']);

          break;
        case 229:

          if (!$$[$0-3]) {
            parser.suggestKeywords(['IF EXISTS']);
          }

          break;
        case 231: case 507:

          parser.addTablePrimary($$[$0-1]);

          break;
        case 233:

          if (!$$[$0-1]) {
            parser.suggestKeywords(['IF EXISTS']);
          }
          parser.suggestTables({ onlyTables: true });
          parser.suggestDatabases({
            appendDot: true
          });

          break;
        case 236:

          parser.addTablePrimary($$[$0-2]);
          if (!$$[$0-1]) {
            parser.suggestKeywords(['PURGE']);
          }

          break;
        case 240:

          if (!$$[$0-1]) {
            parser.suggestKeywords(['IF EXISTS']);
          }
          parser.suggestTables({ onlyViews: true });
          parser.suggestDatabases({ appendDot: true });

          break;
        case 241:

          parser.addTablePrimary($$[$0]);
          if (!$$[$0-2]) {
            parser.suggestKeywords(['IF EXISTS']);
          }

          break;
        case 250:

          $$[$0-2].owner = 'insert';
          parser.addTablePrimary($$[$0-2]);

          break;
        case 251:

          parser.suggestKeywords(['INTO']);

          break;
        case 252:

          if (!$$[$0-1]) {
            parser.suggestKeywords(['TABLE']);
          }
          parser.suggestTables();
          parser.suggestDatabases({ appendDot: true });

          break;
        case 254:

          $$[$0-1].owner = 'insert';
          parser.addTablePrimary($$[$0-1]);
          parser.suggestKeywords(['VALUES']);

          break;
        case 262: case 442:
          this.$ = $$[$0-2];
          break;
        case 264:

          parser.addCommonTableExpressions($$[$0-3]);

          break;
        case 265: case 266: case 277:

          parser.addCommonTableExpressions($$[$0-2]);

          break;
        case 272: case 288: case 312: case 391: case 395: case 437: case 447: case 488: case 638: case 660: case 661: case 662: case 1044: case 1046: case 1101: case 1156: case 1231:
          this.$ = $$[$0];
          break;
        case 275:
          this.$ = $$[$0-2].concat([$$[$0]]);
          break;
        case 279:

          parser.addCommonTableExpressions($$[$0-4]);

          break;
        case 280:

          parser.addCteAliasLocation(_$[$0-4], $$[$0-4]);
          $$[$0-1].alias = $$[$0-4];
          this.$ = $$[$0-1];

          break;
        case 284:

          this.$ = { tableReferenceList : $$[$0] }

          break;
        case 285: case 293:

          parser.suggestTables();
          parser.suggestDatabases({ appendDot: true });

          break;
        case 296:

          this.$ = { valueExpression: $$[$0] };

          break;
        case 297: case 402:

          parser.suggestSelectListAliases();

          break;
        case 298:

          parser.valueExpressionSuggest();
          parser.suggestSelectListAliases();
          parser.suggestGroupBys({ tablePrimaries: parser.yy.latestTablePrimaries.concat() });

          break;
        case 299:

          parser.suggestKeywords(['BY']);
          parser.suggestGroupBys({ prefix: 'BY', tablePrimaries: parser.yy.latestTablePrimaries.concat() });

          break;
        case 309: case 633: case 859: case 862: case 863: case 888: case 889: case 910: case 913:

          parser.suggestColumns();

          break;
        case 314: case 315: case 321: case 322: case 887: case 1115: case 1158:

          parser.valueExpressionSuggest();

          break;
        case 326:

          parser.valueExpressionSuggest();
          parser.suggestAggregateFunctions();
          parser.suggestSelectListAliases(true);

          break;
        case 327:

          parser.suggestAggregateFunctions();
          parser.suggestSelectListAliases(true);

          break;
        case 331:

          if ($$[$0] && $$[$0].valueExpression) {
            this.$ = $$[$0].valueExpression;
          } else {
            this.$ = {};
          }
          this.$.joinType = $$[$0-2];
          if ($$[$0].noJoinCondition) {
            this.$.suggestJoinConditions = { prependOn: true, tablePrimaries: parser.yy.latestTablePrimaries.concat() }
          }
          if ($$[$0].suggestKeywords) {
            this.$.suggestKeywords = $$[$0].suggestKeywords;
          }
          if (parser.yy.latestTablePrimaries.length > 0) {
            parser.yy.latestTablePrimaries[parser.yy.latestTablePrimaries.length - 1].join = true;
          }

          break;
        case 332:

          if ($$[$0] && $$[$0].valueExpression) {
            this.$ = $$[$0].valueExpression;
          } else {
            this.$ = {};
          }
          this.$.joinType = $$[$0-3];
          if ($$[$0].noJoinCondition) {
            this.$.suggestJoinConditions = { prependOn: true, tablePrimaries: parser.yy.latestTablePrimaries.concat() }
          }
          if ($$[$0].suggestKeywords) {
            this.$.suggestKeywords = $$[$0].suggestKeywords;
          }
          if (parser.yy.latestTablePrimaries.length > 0) {
            parser.yy.latestTablePrimaries[parser.yy.latestTablePrimaries.length - 1].join = true;
          }

          break;
        case 333:
          this.$ = { joinType: $$[$0] };
          break;
        case 334:
          this.$ = { joinType: $$[$0-1] };
          break;
        case 335:

          if ($$[$0-2].suggestKeywords) {
            parser.suggestKeywords($$[$0-2].suggestKeywords);
          }

          break;
        case 336:

          if ($$[$0].suggestKeywords) {
            parser.suggestKeywords($$[$0].suggestKeywords);
          }

          break;
        case 339:

          if (parser.yy.latestTablePrimaries.length > 0) {
            var idx = parser.yy.latestTablePrimaries.length - 1;
            var tables = [];
            do {
              var tablePrimary = parser.yy.latestTablePrimaries[idx];
              if (!tablePrimary.subQueryAlias) {
                tables.unshift(tablePrimary.alias ? { identifierChain: tablePrimary.identifierChain, alias: tablePrimary.alias } : { identifierChain: tablePrimary.identifierChain })
              }
              idx--;
            } while (idx >= 0 && tablePrimary.join && !tablePrimary.subQueryAlias)

            if (tables.length > 0) {
              parser.suggestJoins({
                prependJoin: false,
                joinType: $$[$0-2],
                tables: tables
              })
            }
          }
          parser.suggestTables();
          parser.suggestDatabases({
            appendDot: true
          });

          break;
        case 344:
          this.$ = 'CROSS JOIN';
          break;
        case 345:
          this.$ = 'FULL JOIN';
          break;
        case 346:
          this.$ = 'FULL OUTER JOIN';
          break;
        case 347:
          this.$ = 'INNER JOIN';
          break;
        case 348:
          this.$ = 'JOIN';
          break;
        case 349:
          this.$ = 'LEFT INNER JOIN';
          break;
        case 350:
          this.$ = 'LEFT JOIN';
          break;
        case 351:
          this.$ = 'LEFT OUTER JOIN';
          break;
        case 352:
          this.$ = 'LEFT SEMI JOIN';
          break;
        case 353:
          this.$ = 'OUTER JOIN';
          break;
        case 354: case 356:
          this.$ = 'RIGHT OUTER JOIN';
          break;
        case 355:
          this.$ = 'RIGHT JOIN';
          break;
        case 357:
          this.$ = 'RIGHT SEMI JOIN';
          break;
        case 358:
          this.$ = 'SEMI JOIN';
          break;
        case 359: case 361: case 362: case 364: case 365: case 366: case 367: case 369: case 370: case 371: case 372:
          this.$ = { suggestKeywords: ['JOIN'] };
          break;
        case 360: case 363: case 368:
          this.$ = { suggestKeywords: ['OUTER'] };
          break;
        case 373: case 374: case 375:

          parser.suggestKeywords(['JOIN', 'OUTER JOIN']);

          break;
        case 376:
          this.$ = { noJoinCondition: true, suggestKeywords: ['ON'] };
          break;
        case 377:
          this.$ = { valueExpression: $$[$0] };
          break;
        case 381:

          parser.valueExpressionSuggest();
          parser.suggestJoinConditions({ prependOn: false });

          break;
        case 388:

          parser.suggestKeywords([{ value: '10', weight: 10000 }, { value: '100', weight: 10000 }, { value: '1000', weight: 10000 }, { value: '5000', weight: 10000 }, { value: '10000', weight: 10000 }])

          break;
        case 392:

          if ($$[$0].emptyOrderBy) {
            parser.suggestOrderBys({ tablePrimaries: parser.yy.latestTablePrimaries.concat() });
          }

          break;
        case 393:

          parser.suggestKeywords(['BY']);
          parser.suggestOrderBys({ prefix: 'BY', tablePrimaries: parser.yy.latestTablePrimaries.concat() });

          break;
        case 397:

          this.$ = { emptyOrderBy: false }
          parser.valueExpressionSuggest();
          parser.suggestAnalyticFunctions();
          parser.suggestSelectListAliases();

          break;
        case 398: case 399: case 400:
          this.$ = { emptyOrderBy: false };
          break;
        case 401:
          this.$ = parser.mergeSuggestKeywords($$[$0]);
          break;
        case 403:

          this.$ = { emptyOrderBy: true }
          parser.valueExpressionSuggest();
          parser.suggestAnalyticFunctions();
          parser.suggestSelectListAliases();

          break;
        case 404:
          this.$ = { suggestKeywords: ['ASC', 'DESC'] };;
          break;
        case 407:

          parser.addClauseLocation('selectList', parser.firstDefined($$[$0-1], _$[$0-1], $$[$0-2], _$[$0-2]), _$[$0]);
          this.$ = { selectList: $$[$0] };

          break;
        case 408:

          parser.addClauseLocation('selectList', parser.firstDefined($$[$0-2], _$[$0-2], $$[$0-3], _$[$0-3]), _$[$0-1]);
          this.$ = { selectList: $$[$0-1], tableExpression: $$[$0] }

          break;
        case 411:

          parser.addClauseLocation('selectList', parser.firstDefined($$[$0-1], _$[$0-1], $$[$0-2], _$[$0-2]), _$[$0]);
          if ($$[$0].cursorAtStart) {
            var keywords = parser.getSelectListKeywords();
            if (!$$[$0-1]) {
              keywords = keywords.concat(parser.SELECT_FIRST_OPTIONAL_KEYWORDS);
            }
            parser.suggestKeywords(keywords);
          } else {
            parser.checkForSelectListKeywords($$[$0]);
          }
          if ($$[$0].suggestFunctions) {
            parser.suggestFunctions();
          }
          if ($$[$0].suggestColumns) {
            parser.suggestColumns({ identifierChain: [], source: 'select' });
          }
          if ($$[$0].suggestTables) {
            parser.suggestTables({ prependQuestionMark: true, prependFrom: true });
          }
          if ($$[$0].suggestDatabases) {
            parser.suggestDatabases({ prependQuestionMark: true, prependFrom: true, appendDot: true });
          }
          if ($$[$0].suggestAggregateFunctions && (!$$[$0-1] || $$[$0-1] === 'ALL')) {
            parser.suggestAggregateFunctions();
            parser.suggestAnalyticFunctions();
          }

          break;
        case 412:

          parser.addClauseLocation('selectList', parser.firstDefined($$[$0-1], _$[$0-1], $$[$0-2], _$[$0-2]), _$[$0], true);
          var keywords = parser.getSelectListKeywords();
          if (!$$[$0-1] || $$[$0-1] === 'ALL') {
            parser.suggestAggregateFunctions();
            parser.suggestAnalyticFunctions();
          }
          if (!$$[$0-1]) {
            keywords = keywords.concat(parser.SELECT_FIRST_OPTIONAL_KEYWORDS);
          }
          parser.suggestKeywords(keywords);
          parser.suggestFunctions();
          parser.suggestColumns({ identifierChain: [], source: 'select' });
          parser.suggestTables({ prependQuestionMark: true, prependFrom: true });
          parser.suggestDatabases({ prependQuestionMark: true, prependFrom: true, appendDot: true });

          break;
        case 413:

          parser.addClauseLocation('selectList', parser.firstDefined($$[$0-2], _$[$0-2], $$[$0-3], _$[$0-3]), _$[$0-1]);

          break;
        case 414:

          parser.addClauseLocation('selectList', parser.firstDefined($$[$0-2], _$[$0-2], $$[$0-3], _$[$0-3]), _$[$0-1]);
          parser.selectListNoTableSuggest($$[$0-1], $$[$0-2]);
          if (parser.yy.result.suggestColumns) {
            parser.yy.result.suggestColumns.source = 'select';
          }

          break;
        case 415:

          parser.addClauseLocation('selectList', parser.firstDefined($$[$0-2], _$[$0-2], $$[$0-3], _$[$0-3]), _$[$0-1], true);
          var keywords = parser.getSelectListKeywords();
          if (!$$[$0-2] || $$[$0-2] === 'ALL') {
            parser.suggestAggregateFunctions();
            parser.suggestAnalyticFunctions();
          }
          if (!$$[$0-2]) {
            keywords = keywords.concat(parser.SELECT_FIRST_OPTIONAL_KEYWORDS);
          }
          parser.suggestKeywords(keywords);
          parser.suggestFunctions();
          parser.suggestColumns({ identifierChain: [], source: 'select' });
          parser.suggestTables({ prependQuestionMark: true, prependFrom: true });
          parser.suggestDatabases({ prependQuestionMark: true, prependFrom: true, appendDot: true });

          break;
        case 416:

          parser.addClauseLocation('selectList', parser.firstDefined($$[$0-3], _$[$0-3], $$[$0-4], _$[$0-4]), _$[$0-2]);
          parser.checkForSelectListKeywords($$[$0-2]);

          break;
        case 417:

          parser.addClauseLocation('selectList', parser.firstDefined($$[$0-4], _$[$0-4], $$[$0-5], _$[$0-5]), _$[$0-3]);
          parser.checkForSelectListKeywords($$[$0-3]);

          break;
        case 418:

          parser.addClauseLocation('selectList', parser.firstDefined($$[$0-2], _$[$0-2], $$[$0-3], _$[$0-3]), _$[$0-1]);
          parser.checkForSelectListKeywords($$[$0-1]);
          var keywords = ['FROM'];
          if (parser.yy.result.suggestKeywords) {
            keywords = parser.yy.result.suggestKeywords.concat(keywords);
          }
          parser.suggestKeywords(keywords);
          parser.suggestTables({ prependFrom: true });
          parser.suggestDatabases({ prependFrom: true, appendDot: true });

          break;
        case 419:

          parser.selectListNoTableSuggest($$[$0-1], $$[$0-2]);

          break;
        case 424: case 425:

          parser.addClauseLocation('whereClause', _$[$0-1], $$[$0].whereClauseLocation);
          parser.addClauseLocation('limitClause', $$[$0].limitClausePreceding || _$[$0-1], $$[$0].limitClauseLocation);

          break;
        case 426:

          var keywords = [];

          parser.addClauseLocation('whereClause', _$[$0-3], $$[$0-1].whereClauseLocation);
          parser.addClauseLocation('limitClause', $$[$0-2].limitClausePreceding || _$[$0-3], $$[$0-2].limitClauseLocation);

          if ($$[$0-3]) {
            if (typeof $$[$0-3].tableReferenceList.hasJoinCondition !== 'undefined' && !$$[$0-3].tableReferenceList.hasJoinCondition) {
              keywords.push({ value: 'ON', weight: 3 });
            }
            if ($$[$0-3].suggestKeywords) {
              keywords = parser.createWeightedKeywords($$[$0-3].suggestKeywords, 3);
            }
            if ($$[$0-3].tableReferenceList.suggestJoinConditions) {
              parser.suggestJoinConditions($$[$0-3].tableReferenceList.suggestJoinConditions);
            }
            if ($$[$0-3].tableReferenceList.suggestJoins) {
              parser.suggestJoins($$[$0-3].tableReferenceList.suggestJoins);
            }
            if ($$[$0-3].tableReferenceList.suggestKeywords) {
              keywords = keywords.concat(parser.createWeightedKeywords($$[$0-3].tableReferenceList.suggestKeywords, 3));
            }

            // Lower the weights for 'TABLESAMPLE'
            keywords.forEach(function (keyword) {
              if (keyword.value === 'TABLESAMPLE') {
                keyword.weight = 1.1;
              }
            });

            if ($$[$0-3].tableReferenceList.types) {
              var veKeywords = parser.getValueExpressionKeywords($$[$0-3].tableReferenceList);
              keywords = keywords.concat(veKeywords.suggestKeywords);
              if (veKeywords.suggestColRefKeywords) {
                parser.suggestColRefKeywords(veKeywords.suggestColRefKeywords);
                parser.addColRefIfExists($$[$0-3].tableReferenceList);
              }
            }
          }

          if ($$[$0-1].empty && $$[$0] && $$[$0].joinType.toUpperCase() === 'JOIN') {
            keywords = keywords.concat(['FULL', 'FULL OUTER', 'INNER', 'LEFT', 'LEFT OUTER', 'RIGHT', 'RIGHT OUTER']);
            parser.suggestKeywords(keywords);
            return;
          }

          if ($$[$0-1].suggestKeywords) {
            keywords = keywords.concat(parser.createWeightedKeywords($$[$0-1].suggestKeywords, 2));
          }

          if ($$[$0-1].suggestFilters) {
            parser.suggestFilters($$[$0-1].suggestFilters);
          }
          if ($$[$0-1].suggestGroupBys) {
            parser.suggestGroupBys($$[$0-1].suggestGroupBys);
          }
          if ($$[$0-1].suggestOrderBys) {
            parser.suggestOrderBys($$[$0-1].suggestOrderBys);
          }

          if ($$[$0-1].empty) {
            keywords.push({ value: 'UNION', weight: 2.11 });
          }

          keywords = keywords.concat([
            { value: 'FULL JOIN', weight: 1 },
            { value: 'FULL OUTER JOIN', weight: 1 },
            { value: 'INNER JOIN', weight: 1 },
            { value: 'JOIN', weight: 1 },
            { value: 'LEFT JOIN', weight: 1 },
            { value: 'LEFT OUTER JOIN', weight: 1 },
            { value: 'RIGHT JOIN', weight: 1 },
            { value: 'RIGHT OUTER JOIN', weight: 1 }
          ]);
          parser.suggestKeywords(keywords);

          break;
        case 427:

          // A couple of things are going on here:
          // - If there are no SelectConditions (WHERE, GROUP BY, etc.) we should suggest complete join options
          // - If there's an OptionalJoin at the end, i.e. 'SELECT * FROM foo | JOIN ...' we should suggest
          //   different join types
          // - The FromClause could end with a valueExpression, in which case we should suggest keywords like '='
          //   or 'AND' based on type

          if (!$$[$0-1]) {
            parser.addClauseLocation('whereClause', _$[$0-2]);
            parser.addClauseLocation('limitClause', _$[$0-2]);
            return;
          }
          parser.addClauseLocation('whereClause', _$[$0-2], $$[$0-1].whereClauseLocation);
          parser.addClauseLocation('limitClause', $$[$0-1].limitClausePreceding || _$[$0-2], $$[$0-1].limitClauseLocation);
          var keywords = [];

          if ($$[$0-1].suggestColRefKeywords) {
            parser.suggestColRefKeywords($$[$0-1].suggestColRefKeywords);
            parser.addColRefIfExists($$[$0-1]);
          }

          if ($$[$0-1].suggestKeywords && $$[$0-1].suggestKeywords.length) {
            keywords = keywords.concat(parser.createWeightedKeywords($$[$0-1].suggestKeywords, 2));
          }

          if ($$[$0-1].cursorAtEnd) {
            keywords.push({ value: 'UNION', weight: 2.11 });
          }
          parser.suggestKeywords(keywords);

          break;
        case 428:
          this.$ = [ $$[$0] ];
          break;
        case 429:

          $$[$0-2].push($$[$0]);

          break;
        case 431: case 432: case 665:

          this.$ = { cursorAtStart : true, suggestFunctions: true, suggestColumns: true, suggestAggregateFunctions: true };

          break;
        case 434:

          parser.checkForSelectListKeywords($$[$0-2]);

          break;
        case 435:

          parser.checkForSelectListKeywords($$[$0-3]);

          break;
        case 436:

          this.$ = { suggestKeywords: parser.getSelectListKeywords(), suggestTables: true, suggestDatabases: true, suggestFunctions: true, suggestColumns: true, suggestAggregateFunctions: true };

          break;
        case 438: case 439: case 441:

          this.$ = { suggestKeywords: parser.getSelectListKeywords(), suggestFunctions: true, suggestColumns: true, suggestAggregateFunctions: true,  };

          break;
        case 443:

          if ($$[$0]) {
            parser.addColumnAliasLocation($$[$0].location, $$[$0].alias, _$[$0-1]);
            this.$ = { valueExpression: $$[$0-1], alias: $$[$0].alias };
            if (!parser.yy.selectListAliases) {
              parser.yy.selectListAliases = [];
            }
            parser.yy.selectListAliases.push($$[$0-1].function && $$[$0-1].types && $$[$0-1].types.length && $$[$0-1].types[0] === 'UDFREF' ? { name: $$[$0].alias, udfRef: $$[$0-1].function, types: $$[$0-1].types } : { name: $$[$0].alias, types: $$[$0-1].types || ['T'] });
          } else {
            this.$ = { valueExpression: $$[$0-1] }
          }

          break;
        case 444:

          parser.addAsteriskLocation(_$[$0], [{ asterisk: true }]);
          this.$ = { asterisk: true }

          break;
        case 445:

          if ($$[$0]) {
            parser.addColumnAliasLocation($$[$0].location, $$[$0].alias, _$[$0-1]);
          }

          break;
        case 446:

          parser.suggestFunctions();
          parser.suggestColumns();
          parser.addColumnAliasLocation(_$[$0], $$[$0], _$[$0-2]);
          this.$ = { suggestAggregateFunctions: true };

          break;
        case 448:

          var keywords = parser.getKeywordsForOptionalsLR(
            [$$[$0-4], $$[$0-3], $$[$0-2], $$[$0-1], $$[$0]],
            [{ value: 'WHERE', weight: 7 }, { value: 'GROUP BY', weight: 6 }, { value: 'HAVING', weight: 5 }, { value: 'ORDER BY', weight: 4 }, { value: 'LIMIT', weight: 3 }],
            [true, true, true, true, true]);

          if (keywords.length > 0) {
            this.$ = { suggestKeywords: keywords, empty: !$$[$0-4] && !$$[$0-3] && !$$[$0-2] && !$$[$0-1] && !$$[$0] };
          } else {
            this.$ = {};
          }

          this.$.whereClauseLocation = $$[$0-4] ? _$[$0-4] : undefined;
          this.$.limitClausePreceding = parser.firstDefined($$[$0-1], _$[$0-1], $$[$0-2], _$[$0-2], $$[$0-3], _$[$0-3], $$[$0-4], _$[$0-4]);
          this.$.limitClauseLocation = $$[$0] ? _$[$0] : undefined;

          if (!$$[$0-4] && !$$[$0-3] && !$$[$0-2] && !$$[$0-1] && !$$[$0]) {
            this.$.suggestFilters = { prefix: 'WHERE', tablePrimaries: parser.yy.latestTablePrimaries.concat() };
          }
          if (!$$[$0-3] && !$$[$0-2] && !$$[$0-1] && !$$[$0]) {
            this.$.suggestGroupBys = { prefix: 'GROUP BY', tablePrimaries: parser.yy.latestTablePrimaries.concat() };
          }
          if (!$$[$0-1] && !$$[$0]) {
            this.$.suggestOrderBys = { prefix: 'ORDER BY', tablePrimaries: parser.yy.latestTablePrimaries.concat() };
          }

          break;
        case 449:

          if (parser.yy.result.suggestColumns) {
            parser.yy.result.suggestColumns.source = 'where';
          }

          break;
        case 450:

          if (parser.yy.result.suggestColumns) {
            parser.yy.result.suggestColumns.source = 'group by';
          }

          break;
        case 452:

          if (parser.yy.result.suggestColumns) {
            parser.yy.result.suggestColumns.source = 'order by';
          }

          break;
        case 454:

          var keywords = parser.getKeywordsForOptionalsLR(
            [$$[$0-3], $$[$0-2], $$[$0-1], $$[$0]],
            [{ value: 'GROUP BY', weight: 8 }, { value: 'HAVING', weight: 7 }, { value: 'ORDER BY', weight: 5 }, { value: 'LIMIT', weight: 3 }],
            [true, true, true, true]);
          if ($$[$0-5].suggestKeywords) {
            keywords = keywords.concat(parser.createWeightedKeywords($$[$0-5].suggestKeywords, 1));
          }
          this.$ = parser.getValueExpressionKeywords($$[$0-5], keywords);
          this.$.cursorAtEnd = !$$[$0-3] && !$$[$0-2] && !$$[$0-1] && !$$[$0];
          if ($$[$0-5].columnReference) {
            this.$.columnReference = $$[$0-5].columnReference;
          }
          if (!$$[$0-3]) {
            parser.suggestGroupBys({ prefix: 'GROUP BY', tablePrimaries: parser.yy.latestTablePrimaries.concat() });
          }
          if (!$$[$0-3] && !$$[$0-2] && !$$[$0-1]) {
            parser.suggestOrderBys({ prefix: 'ORDER BY', tablePrimaries: parser.yy.latestTablePrimaries.concat() });
          }
          this.$.whereClauseLocation = $$[$0-5] ? _$[$0-5] : undefined;
          this.$.limitClausePreceding = parser.firstDefined($$[$0-1], _$[$0-1], $$[$0-2], _$[$0-2], $$[$0-3], _$[$0-3], $$[$0-5], _$[$0-5]);
          this.$.limitClauseLocation = $$[$0] ? _$[$0] : undefined;

          break;
        case 455:

          var keywords = parser.getKeywordsForOptionalsLR(
            [$$[$0-2], $$[$0-1], $$[$0]],
            [{ value: 'HAVING', weight: 7 }, { value: 'ORDER BY', weight: 5 }, { value: 'LIMIT', weight: 3 }],
            [true, true, true]);
          if ($$[$0-4].suggestKeywords) {
            keywords = keywords.concat(parser.createWeightedKeywords($$[$0-4].suggestKeywords, 8));
          }
          if ($$[$0-4].valueExpression) {
            this.$ = parser.getValueExpressionKeywords($$[$0-4].valueExpression, keywords);
            if ($$[$0-4].valueExpression.columnReference) {
              this.$.columnReference = $$[$0-4].valueExpression.columnReference;
            }
          } else {
            this.$ = { suggestKeywords: keywords };
          }
          this.$.cursorAtEnd = !$$[$0-2] && !$$[$0-1] && !$$[$0];
          if (!$$[$0-2] && !$$[$0-1]) {
            parser.suggestOrderBys({ prefix: 'ORDER BY', tablePrimaries: parser.yy.latestTablePrimaries.concat() });
          }
          this.$.whereClauseLocation = $$[$0-5] ? _$[$0-5] : undefined;
          this.$.limitClausePreceding = parser.firstDefined($$[$0-1], _$[$0-1], $$[$0-2], _$[$0-2], $$[$0-4], _$[$0-4]);
          this.$.limitClauseLocation = $$[$0] ? _$[$0] : undefined;

          break;
        case 456:

          var keywords = parser.getKeywordsForOptionalsLR(
            [$$[$0-1], $$[$0]],
            [{ value: 'ORDER BY', weight: 5 }, { value: 'LIMIT', weight: 3 }],
            [true, true]);
          this.$ = { suggestKeywords: keywords, cursorAtEnd: !$$[$0-1] && !$$[$0] };
          if (!$$[$0-1]) {
            parser.suggestOrderBys({ prefix: 'ORDER BY', tablePrimaries: parser.yy.latestTablePrimaries.concat() });
          }
          this.$.whereClauseLocation = $$[$0-5] ? _$[$0-5] : undefined;
          this.$.limitClausePreceding = parser.firstDefined($$[$0-1], _$[$0-1], $$[$0-3], _$[$0-3]);
          this.$.limitClauseLocation = $$[$0] ? _$[$0] : undefined;

          break;
        case 457:

          var keywords = parser.getKeywordsForOptionalsLR(
            [$$[$0]],
            [{ value: 'LIMIT', weight: 3 }],
            [true]);
          if ($$[$0-2].suggestKeywords) {
            keywords = keywords.concat(parser.createWeightedKeywords($$[$0-2].suggestKeywords, 4));
          }
          this.$ = { suggestKeywords: keywords, cursorAtEnd: !$$[$0] };
          this.$.whereClauseLocation = $$[$0-5] ? _$[$0-5] : undefined;
          this.$.limitClausePreceding = parser.firstDefined($$[$0-2], _$[$0-2]);
          this.$.limitClauseLocation = $$[$0] ? _$[$0] : undefined;

          break;
        case 458:

          this.$ = { suggestKeywords: [], cursorAtEnd: true };
          this.$.whereClauseLocation = $$[$0-5] ? _$[$0-5] : undefined;
          this.$.limitClausePreceding = parser.firstDefined($$[$0-2], _$[$0-2], $$[$0-3], _$[$0-3], $$[$0-4], _$[$0-4], $$[$0-5], _$[$0-5]);
          this.$.limitClauseLocation = _$[$0-1];

          break;
        case 459:

          this.$ = {
            suggestKeywords: parser.getKeywordsForOptionalsLR([$$[$0-3], $$[$0-2], $$[$0-1], $$[$0]], [{ value: 'GROUP BY', weight: 8 }, { value: 'HAVING', weight: 7 }, { value: 'ORDER BY', weight: 5 }, { value: 'LIMIT', weight: 3 }], [true, true, true, true]),
            cursorAtEnd: !$$[$0-3] && !$$[$0-2] && !$$[$0-1] && !$$[$0]
          };

          break;
        case 460:

          this.$ = {
            suggestKeywords: parser.getKeywordsForOptionalsLR([$$[$0-1], $$[$0]], [{ value: 'ORDER BY', weight: 5 }, { value: 'LIMIT', weight: 3 }], [true, true]),
            cursorAtEnd: !$$[$0-1] && !$$[$0]
          }

          break;
        case 461:

          this.$ = {
            suggestKeywords: parser.getKeywordsForOptionalsLR([$$[$0]], [{ value: 'LIMIT', weight: 3 }], [true]),
            cursorAtEnd: !$$[$0]
          }

          break;
        case 483:

          parser.suggestKeywords(['ALL', 'DISTINCT', 'SELECT']);

          break;
        case 484:

          parser.suggestKeywords(['ALL', 'DISTINCT']);

          break;
        case 489:

          if ($$[$0].suggestFilters) {
            parser.suggestFilters({ tablePrimaries: parser.yy.latestTablePrimaries.concat() });
          }

          break;
        case 490:

          parser.suggestFunctions();
          parser.suggestColumns();
          parser.suggestKeywords(['EXISTS', 'NOT EXISTS']);
          parser.suggestFilters({ tablePrimaries: parser.yy.latestTablePrimaries.concat() });

          break;
        case 503:

          parser.suggestKeywords(['TABLE']);

          break;
        case 504:

          parser.suggestTables();
          parser.suggestDatabases({ appendDot: true });
          if (!$$[$0-1]) {
            parser.suggestKeywords(['IF EXISTS']);
          }

          break;
        case 508:

          parser.addTablePrimary($$[$0-1]);
          if (!$$[$0-2]) {
            parser.suggestKeywords(['IF EXISTS']);
          }

          break;
        case 510:

          if (!$$[$0]) {
            $$[$0-1].suggestKeywords = ['OVER'];
          }

          break;
        case 517:

          parser.suggestKeywords(['OVER']);

          break;
        case 526:

          this.$ = { function: $$[$0-3], types: ['UDFREF'] };

          break;
        case 527: case 545:

          parser.addFunctionArgumentLocations($$[$0-4], $$[$0-1].expressions);
          this.$ = { function: $$[$0-4], types: ['UDFREF'] };

          break;
        case 528:

          parser.valueExpressionSuggest();
          var keywords = parser.getSelectListKeywords(true);
          if (!$$[$0-2]) {
            if ($$[$0-4].toLowerCase() === 'group_concat') {
              keywords.push('ALL');
            } else {
              keywords.push('DISTINCT');
            }
          }
          if (parser.yy.result.suggestKeywords) {
            keywords = parser.yy.result.suggestKeywords.concat(keywords);
          }
          parser.suggestKeywords(keywords);
          parser.applyArgumentTypesToSuggestions($$[$0-4], 1);
          this.$ = { function: $$[$0-4], types: ['UDFREF'] };

          break;
        case 529: case 543:

          parser.suggestValueExpressionKeywords($$[$0-2].expressions[$$[$0-2].expressions.length - 1].expression);
          this.$ = { function: $$[$0-5], types: ['UDFREF'] };

          break;
        case 530:

          if ($$[$0-1].cursorAtStart) {
            var keywords = parser.getSelectListKeywords(true);
            if (!$$[$0-2]) {
              if ($$[$0-4].toLowerCase() === 'group_concat') {
                keywords.push('ALL');
              } else {
                keywords.push('DISTINCT');
              }
            }
            if (parser.yy.result.suggestKeywords) {
              keywords = parser.yy.result.suggestKeywords.concat(keywords);
            }
            parser.suggestKeywords(keywords);
          }
          if (parser.yy.result.suggestFunctions && !parser.yy.result.suggestFunctions.types) {
            parser.applyArgumentTypesToSuggestions($$[$0-4], $$[$0-1].activePosition);
          }
          this.$ = { function: $$[$0-4], types: ['UDFREF'] };

          break;
        case 539:

          parser.addFunctionArgumentLocations($$[$0-3], [{
            expression: { text: $$[$0-1] },
            location: _$[$0-1]
          }]);
          this.$ = { function: $$[$0-3], types: ['UDFREF'] }

          break;
        case 540: case 546:

          this.$ = { function: $$[$0-2], types: ['UDFREF'] }

          break;
        case 541:

          parser.addFunctionArgumentLocations($$[$0-4], $$[$0-1].expressions);
          this.$ = { function: $$[$0-4], types: ['UDFREF'] }

          break;
        case 542:

          parser.valueExpressionSuggest();
          var keywords = parser.getSelectListKeywords();
          if (!$$[$0-2]) {
            keywords.push('DISTINCT');
            if (parser.yy.result.suggestKeywords) {
              keywords = parser.yy.result.suggestKeywords.concat(keywords);
            }
          }
          parser.suggestKeywords(keywords);
          this.$ = { function: $$[$0-4], types: ['UDFREF'] };

          break;
        case 544:

          if ($$[$0-1].cursorAtStart) {
            var keywords = parser.getSelectListKeywords();
            if (!$$[$0-2]) {
              keywords.push('DISTINCT');
            }
            parser.suggestKeywords(keywords);
          }
          this.$ = { function: $$[$0-4], types: ['UDFREF'] };

          break;
        case 547:

          parser.valueExpressionSuggest();
          parser.applyArgumentTypesToSuggestions($$[$0-4], 1);
          var keywords = parser.getSelectListKeywords(true);
          if (!$$[$0-2]) {
            keywords.push('DISTINCT');
          }
          if (parser.yy.result.suggestKeywords) {
            keywords = parser.yy.result.suggestKeywords.concat(keywords);
          }
          parser.suggestKeywords(keywords);
          this.$ = { function: $$[$0-4], types: ['UDFREF'] };

          break;
        case 548:

          parser.suggestValueExpressionKeywords($$[$0-2]);
          this.$ = { function: $$[$0-5], types: ['UDFREF'] };

          break;
        case 549:

          if (parser.yy.result.suggestFunctions && !parser.yy.result.suggestFunctions.types) {
            parser.applyArgumentTypesToSuggestions($$[$0-4], 1);
          }
          this.$ = { function: $$[$0-4], types: ['UDFREF'] };

          break;
        case 550:

          this.$ = { function: $$[$0-2], types: ['UDFREF'] }

          break;
        case 551:

          parser.addFunctionArgumentLocations($$[$0-3], $$[$0-1].expressions);
          this.$ = {
            function: $$[$0-3],
            expression: $$[$0-1].expressions[$$[$0-1].expressions.length - 1].expression,
            types: ['UDFREF']
          }

          break;
        case 552:

          parser.valueExpressionSuggest();
          parser.applyArgumentTypesToSuggestions($$[$0-3], 1);
          this.$ = { function: $$[$0-3], types: ['UDFREF'] };

          break;
        case 553:

          parser.addFunctionArgumentLocations($$[$0-4], $$[$0-2].expressions);
          parser.suggestValueExpressionKeywords($$[$0-2].expressions[$$[$0-2].expressions.length - 1].expression);
          this.$ = { function: $$[$0-4], types: ['UDFREF'] };

          break;
        case 554:

          parser.addFunctionArgumentLocations($$[$0-3], $$[$0-1].expressions);
          parser.applyArgumentTypesToSuggestions($$[$0-3], $$[$0-1].activePosition);
          this.$ = { function: $$[$0-3], types: ['UDFREF'] };

          break;
        case 559:

          var expression = $$[$0-3];
          parser.extractExpressionText(expression, $$[$0-3], $$[$0-2], $$[$0-1]);
          parser.addFunctionArgumentLocations($$[$0-5], [{
            expression: expression,
            location: {
              first_line: _$[$0-3].first_line,
              last_line: _$[$0-1].last_line,
              first_column: _$[$0-3].first_column,
              last_column: _$[$0-1].last_column
            }
          }]);
          this.$ = { types: [ $$[$0-1].toUpperCase() ] }

          break;
        case 560: case 565: case 566: case 1050:
          this.$ = { types: [ 'T' ] };
          break;
        case 561:

          parser.valueExpressionSuggest();
          this.$ = { types: [ $$[$0-1].toUpperCase() ] };

          break;
        case 562: case 563:

          parser.valueExpressionSuggest();
          this.$ = { types: [ 'T' ] };

          break;
        case 564:
          this.$ = { types: [ $$[$0-1].toUpperCase() ] };
          break;
        case 567:

          parser.suggestValueExpressionKeywords($$[$0-3], [{ value: 'AS', weight: 2 }]);
          this.$ =  { types: [ $$[$0-1].toUpperCase() ] };

          break;
        case 568:

          parser.suggestValueExpressionKeywords($$[$0-2], [{ value: 'AS', weight: 2 }]);
          this.$ = { types: [ 'T' ] };

          break;
        case 569: case 570:

          parser.suggestKeywords(parser.getTypeKeywords());
          this.$ = { types: [ 'T' ] };

          break;
        case 571:

          // We need to handle arbitrary UDFs here instead of inside UserDefinedFunction or there will be a conflict
          // with columnReference for functions like: db.udf(foo)
          var fn = $$[$0-1].chain[$$[$0-1].chain.length - 1].name.toLowerCase();
          parser.addFunctionArgumentLocations(fn, $$[$0].expressions, $$[$0-1].chain);
          if ($$[$0-1].lastLoc && $$[$0-1].lastLoc.location) {
            $$[$0-1].lastLoc.type = 'function';
            $$[$0-1].lastLoc.function = fn;
            $$[$0-1].lastLoc.location = {
              first_line: $$[$0-1].lastLoc.location.first_line,
              last_line: $$[$0-1].lastLoc.location.last_line,
              first_column: $$[$0-1].lastLoc.location.first_column,
              last_column: $$[$0-1].lastLoc.location.last_column - 1
            }
            if ($$[$0-1].lastLoc !== $$[$0-1].firstLoc) {
              $$[$0-1].firstLoc.type = 'database';
            } else {
              delete $$[$0-1].lastLoc.identifierChain;
            }
          }
          if ($$[$0].expressions && $$[$0].expressions.length) {
            this.$ = { function: fn, expression: $$[$0].expressions[$$[$0].expressions.length - 1].expression, types: ['UDFREF'] }
          } else {
            this.$ = { function: fn, types: ['UDFREF'] }
          }

          break;
        case 572:

          parser.addFunctionLocation(_$[$0-1], $$[$0-1]);
          if ($$[$0].expressions && $$[$0].expressions.length) {
            this.$ = { function: $$[$0-1], expression: $$[$0].expressions[$$[$0].expressions.length - 1].expression, types: ['UDFREF'] }
          } else {
            this.$ = { function: $$[$0-1], types: ['UDFREF'] }
          }

          break;
        case 575:
          this.$ = { types: ['COLREF'], columnReference: $$[$0].chain };
          break;
        case 576:
          this.$ = { types: [ 'NULL' ], text: $$[$0] };
          break;
        case 577:

          var fn = $$[$0-1].chain[$$[$0-1].chain.length - 1].name.toLowerCase();
          parser.addFunctionArgumentLocations(fn, $$[$0].expressions, $$[$0-1].chain);
          $$[$0-1].lastLoc.type = 'function';
          $$[$0-1].lastLoc.function = fn;
          $$[$0-1].lastLoc.location = {
            first_line: $$[$0-1].lastLoc.location.first_line,
            last_line: $$[$0-1].lastLoc.location.last_line,
            first_column: $$[$0-1].lastLoc.location.first_column,
            last_column: $$[$0-1].lastLoc.location.last_column - 1
          }
          if ($$[$0-1].lastLoc !== $$[$0-1].firstLoc) {
            $$[$0-1].firstLoc.type = 'database';
          } else {
            delete $$[$0-1].lastLoc.identifierChain;
          }
          if ($$[$0].activePosition) {
            parser.applyArgumentTypesToSuggestions(fn, $$[$0].activePosition);
          }
          this.$ = { function: fn, types: ['UDFREF'] };

          break;
        case 578: case 584: case 585:

          parser.addFunctionLocation(_$[$0-1], $$[$0-1]);
          parser.addFunctionArgumentLocations($$[$0-1], $$[$0].expressions);
          if ($$[$0].activePosition) {
            parser.applyArgumentTypesToSuggestions($$[$0-1], $$[$0].activePosition);
          }
          this.$ = { function: $$[$0-1], types: ['UDFREF'] };

          break;
        case 581:

          if ($$[$0].suggestKeywords) {
            this.$ = { types: ['COLREF'], columnReference: $$[$0], suggestKeywords: $$[$0].suggestKeywords };
          } else {
            this.$ = { types: ['COLREF'], columnReference: $$[$0] };
          }

          break;
        case 582: case 583:

          parser.addFunctionLocation(_$[$0-1], $$[$0-1]);
          parser.addFunctionArgumentLocations($$[$0-1], $$[$0].expressions);
          if ($$[$0].expressions && $$[$0].expressions.length) {
            this.$ = { function: $$[$0-1], expression: $$[$0].expressions[$$[$0].expressions.length - 1].expression, types: ['UDFREF'] }
          } else {
            this.$ = { function: $$[$0-1], types: ['UDFREF'] }
          }

          break;
        case 588:

          parser.valueExpressionSuggest();
          this.$ = {
            activePosition: 1,
            expressions: [{ expression: { text: '' }, location: _$[$0-1] }]
          }

          break;
        case 589:

          parser.suggestValueExpressionKeywords($$[$0-2].expressions[$$[$0-2].expressions.length - 1].expression);
          this.$ = $$[$0-3];

          break;
        case 591: case 593:

          this.$ = {
            activePosition: 1,
            expressions: [{ expression: $$[$0], location: _$[$0] }]
          }

          break;
        case 592: case 594:

          this.$ = {
            activePosition: $$[$0-2].activePosition + 1,
            expressions: $$[$0-2].expressions.concat([{ expression: $$[$0], location: _$[$0] }])
          }

          break;
        case 595:

          this.$ = {
            activePosition: 1,
            expressions: [{ expression: $$[$0-2], location: _$[$0-2] }].concat($$[$0].expressions)
          }

          break;
        case 596:

          this.$ = {
            activePosition: $$[$0-4].activePosition + 1,
            expressions: $$[$0-4].expressions.concat([{ expression: $$[$0-2], location: _$[$0-2] }]).concat($$[$0].expressions)
          }

          break;
        case 597:

          parser.valueExpressionSuggest();
          this.$ = {
            activePosition: $$[$0-2].activePosition + 1,
            expressions: $$[$0-2].expressions.concat([{ expression: { text: '' }, location: _$[$0] }])
          }

          break;
        case 598:

          parser.valueExpressionSuggest();
          this.$ = {
            activePosition: $$[$0-4].activePosition + 1,
            expressions: $$[$0-4].expressions.concat([{ expression: { text: '' }, location: _$[$0-2] }]).concat($$[$0].expressions)
          }

          break;
        case 599:

          parser.suggestValueExpressionKeywords($$[$0-3].expressions[$$[$0-3].expressions.length - 1].expression);
          this.$ = {
            activePosition: $$[$0-3].activePosition,
            expressions: $$[$0-3].expressions.concat($$[$0].expressions)
          }

          break;
        case 600:

          parser.valueExpressionSuggest();
          this.$ = {
            cursorAtStart : true,
            activePosition: 1,
            expressions: [{ expression: { text: '' }, location: _$[$0-2] }].concat($$[$0].expressions)
          };

          break;
        case 601:

          parser.valueExpressionSuggest();
          this.$ = {
            cursorAtStart : true,
            activePosition: 1,
            expressions: [{ expression: { text: '' }, location: _$[$0-1] }, { expression: { text: '' }, location: _$[$0] }]
          };

          break;
        case 602:

          parser.valueExpressionSuggest();
          this.$ = {
            activePosition: 2,
            expressions: [{ expression: { text: '' }, location: _$[$0-1] }, { expression: { text: '' }, location: _$[$0] }]
          };

          break;
        case 603:

          parser.valueExpressionSuggest();
          this.$ = {
            activePosition: 2,
            expressions: [{ expression: { text: '' }, location: _$[$0-3] }, { expression: { text: '' }, location: _$[$0-2] }].concat($$[$0].expressions)
          };

          break;
        case 615:

          parser.suggestKeywords([ 'WHERE' ]);

          break;
        case 616:

          parser.suggestKeywords([ 'SET' ]);

          break;
        case 632:

          parser.suggestKeywords([ '=' ]);

          break;
        case 641:

          if (! parser.yy.cursorFound) {
            parser.yy.result.useDatabase = $$[$0];
          }

          break;
        case 642: case 878:

          parser.suggestDatabases();

          break;
        case 646: case 673: case 675:

          parser.addStatementLocation(_$[$0]);

          break;
        case 648: case 649:

          parser.suggestDdlAndDmlKeywords();

          break;
        case 663: case 664:

          this.$ = { cursorAtStart : false, suggestFunctions: true, suggestColumns: true, suggestAggregateFunctions: true };

          break;
        case 670: case 671:

          return parser.yy.result;

          break;
        case 672:

          parser.prepareNewStatement();

          break;
        case 674: case 676:

          parser.addStatementLocation(_$[$0-3]);

          break;
        case 803: case 806: case 892:
          this.$ = '';
          break;
        case 818: case 821:

          parser.yy.correlatedSubQuery = false;

          break;
        case 819: case 823:

          parser.suggestKeywords(['EXISTS']);

          break;
        case 822:

          parser.suggestKeywords(['NOT EXISTS']);

          break;
        case 833: case 835: case 836: case 838:

          parser.suggestKeywords(['<', '<=', '<>', '=', '>', '>=']);

          break;
        case 867: case 893:

          parser.addTableLocation(_$[$0], [ { name: $$[$0] } ]);
          this.$ = { identifierChain: [ { name: $$[$0] } ] };

          break;
        case 868: case 894:

          parser.addDatabaseLocation(_$[$0-2], [ { name: $$[$0-2] } ]);
          parser.addTableLocation(_$[$0], [ { name: $$[$0-2] }, { name: $$[$0] } ]);
          this.$ = { identifierChain: [ { name: $$[$0-2] }, { name: $$[$0] } ] };

          break;
        case 870: case 875:

          parser.suggestDatabases();
          this.$ = { identifierChain: [{ name: $$[$0-2] }] };

          break;
        case 871: case 896:

          parser.suggestTablesOrColumns($$[$0-2]);

          break;
        case 872:
          this.$ = [{ name: $$[$0] }];
          break;
        case 873:
          this.$ = [{ name: $$[$0-2] }, { name: $$[$0-1] }];
          break;
        case 874:

          parser.suggestDatabases({ appendDot: true });

          break;
        case 895:

          parser.suggestTables();
          parser.suggestDatabases({ prependDot: true });

          break;
        case 898:
          this.$ = { identifierChain: $$[$0-1].identifierChain, alias: $$[$0] };
          break;
        case 901:

          parser.yy.locations[parser.yy.locations.length - 1].type = 'column';

          break;
        case 902: case 1067:

          parser.addAsteriskLocation(_$[$0], $$[$0-2].concat({ asterisk: true }));

          break;
        case 904:

          this.$ = [ $$[$0].identifier ];
          parser.yy.firstChainLocation = parser.addUnknownLocation($$[$0].location, [ $$[$0].identifier ]);

          break;
        case 905:

          if (parser.yy.firstChainLocation) {
            parser.yy.firstChainLocation.firstInChain = true;
            delete parser.yy.firstChainLocation;
          }
          $$[$0-2].push($$[$0].identifier);
          parser.addUnknownLocation($$[$0].location, $$[$0-2].concat());

          break;
        case 906:

          parser.suggestColumns({
            identifierChain: $$[$0-2]
          });
          this.$ = { suggestKeywords: [{ value: '*', weight: 10000 }] };

          break;
        case 907:

          parser.suggestColumns({
            identifierChain: $$[$0-4]
          });
          this.$ = { suggestKeywords: [{ value: '*', weight: 10000 }] };

          break;
        case 908:
          this.$ = [ $$[$0].identifier ];
          break;
        case 909:

          $$[$0-2].push($$[$0].identifier);

          break;
        case 911:

          parser.suggestColumns({ identifierChain: $$[$0-2] });

          break;
        case 912:

          parser.suggestColumns({ identifierChain: $$[$0-4] });

          break;
        case 914:
          this.$ = { identifier: { name: $$[$0] }, location: _$[$0] };
          break;
        case 935: case 936:

          // verifyType($$[$0], 'BOOLEAN');
          this.$ = { types: [ 'BOOLEAN' ] };
          parser.extractExpressionText(this.$, $$[$0-1], $$[$0]);

          break;
        case 937: case 962:

          this.$ = $$[$0];
          parser.extractExpressionText(this.$, $$[$0-1], $$[$0]);

          break;
        case 938:

          // verifyType($$[$0], 'NUMBER');
          this.$ = $$[$0];
          $$[$0].types = ['NUMBER'];
          parser.extractExpressionText(this.$, $$[$0-1], $$[$0]);

          break;
        case 939: case 940: case 941:

          this.$ = { types: [ 'BOOLEAN' ] };
          parser.extractExpressionText(this.$, $$[$0-3], $$[$0-2], $$[$0-1], $$[$0]);

          break;
        case 942:

          this.$ = { types: [ 'BOOLEAN' ] };
          parser.extractExpressionText(this.$, $$[$0-5], $$[$0-4], $$[$0-3], $$[$0-2], $$[$0-1], $$[$0]);

          break;
        case 943:

          this.$ = { types: [ 'BOOLEAN' ] };
          // clear correlated flag after completed sub-query (set by lexer)
          parser.yy.correlatedSubQuery = false;

          break;
        case 945: case 946: case 947: case 948:

          parser.addColRefToVariableIfExists($$[$0-2], $$[$0]);
          this.$ = { types: [ 'BOOLEAN' ] };
          parser.extractExpressionText(this.$, $$[$0-2], $$[$0-1], $$[$0]);

          break;
        case 949: case 950: case 951: case 952: case 982: case 1040: case 1041:
          this.$ = { types: [ 'BOOLEAN' ] };
          break;
        case 953:

          this.$ = { types: [ 'BOOLEAN' ] }
          parser.extractExpressionText(this.$, $$[$0-5], $$[$0-4], $$[$0-3], $$[$0-2], $$[$0-1], $$[$0]);

          break;
        case 954:

          this.$ = { types: [ 'BOOLEAN' ] }
          parser.extractExpressionText(this.$, $$[$0-4], $$[$0-3], $$[$0-2], $$[$0-1], $$[$0]);

          break;
        case 955: case 956:

          // verifyType($$[$0-2], 'BOOLEAN');
          // verifyType($$[$0], 'BOOLEAN');
          this.$ = { types: [ 'BOOLEAN' ] };
          parser.extractExpressionText(this.$, $$[$0-2], $$[$0-1], $$[$0]);

          break;
        case 957: case 958: case 959:

          // verifyType($$[$0-2], 'NUMBER');
          // verifyType($$[$0], 'NUMBER');
          this.$ = { types: [ 'NUMBER' ] };
          parser.extractExpressionText(this.$, $$[$0-2], $$[$0-1], $$[$0]);

          break;
        case 960:

          this.$ = { types: [ 'BOOLEAN' ] };
          parser.extractExpressionText(this.$, $$[$0-1], $$[$0]);

          break;
        case 961:

          this.$ = { types: [ 'BOOLEAN' ] };
          parser.extractExpressionText(this.$, $$[$0-2], $$[$0-1], $$[$0]);

          break;
        case 963:

          this.$ = $$[$0];
          parser.extractExpressionText(this.$, $$[$0-2], $$[$0-1], $$[$0]);

          break;
        case 965:

          parser.suggestKeywords(['BETWEEN', 'EXISTS', 'IN', 'LIKE', 'REGEXP', 'ILIKE']);
          this.$ = { types: [ 'BOOLEAN' ] };

          break;
        case 966: case 968:
          this.$ = { types: [ 'BOOLEAN' ], suggestFilters: $$[$0].suggestFilters };
          break;
        case 967:

          parser.suggestFunctions();
          parser.suggestColumns();
          parser.suggestKeywords(['EXISTS']);
          this.$ = { types: [ 'BOOLEAN' ] };

          break;
        case 969:

          parser.suggestFunctions({ types: [ 'BOOLEAN' ] });
          parser.suggestColumns({ types: [ 'BOOLEAN' ] });
          this.$ = { types: [ 'BOOLEAN' ] };

          break;
        case 970:
          this.$ = { types: [ 'T' ], suggestFilters: $$[$0].suggestFilters };
          break;
        case 971:

          parser.suggestFunctions();
          parser.suggestColumns();
          this.$ = { types: [ 'T' ] };

          break;
        case 972:

          if (!$$[$0].typeSet) {
            parser.applyTypeToSuggestions({ types: ['NUMBER'] });
          }
          this.$ = { types: [ 'NUMBER' ], suggestFilters: $$[$0].suggestFilters };

          break;
        case 973:

          parser.suggestFunctions({ types: [ 'NUMBER' ] });
          parser.suggestColumns({ types: [ 'NUMBER' ] });
          this.$ = { types: [ 'NUMBER' ] };

          break;
        case 974:

          parser.suggestKeywords(['FALSE', 'NOT NULL', 'NOT TRUE', 'NOT FALSE', 'NULL', 'TRUE']);
          this.$ = { types: [ 'BOOLEAN' ] };

          break;
        case 975:

          parser.suggestKeywords(['FALSE', 'NULL', 'TRUE']);
          this.$ = { types: [ 'BOOLEAN' ] };

          break;
        case 976:

          this.$ = { types: [ 'BOOLEAN' ] };

          break;
        case 977: case 978: case 979:

          parser.suggestKeywords(['NOT']);
          this.$ = { types: [ 'BOOLEAN' ] };

          break;
        case 980:

          parser.valueExpressionSuggest($$[$0-5], $$[$0-3] ? 'IS NOT DISTINCT FROM' : 'IS DISTINCT FROM');
          this.$ = { types: [ 'BOOLEAN' ] };

          break;
        case 981:

          this.$ = { types: [ 'BOOLEAN' ], suggestFilters: $$[$0].suggestFilters }

          break;
        case 983:

          this.$ = $$[$0-1];

          break;
        case 984:

          parser.valueExpressionSuggest();
          this.$ = { types: ['T'], typeSet: true };

          break;
        case 985:

          parser.valueExpressionSuggest($$[$0], $$[$0-1]);
          parser.applyTypeToSuggestions($$[$0]);
          this.$ = { types: [ 'BOOLEAN' ], typeSet: true };

          break;
        case 986: case 987: case 988:

          parser.valueExpressionSuggest($$[$0], $$[$0-1]);
          parser.applyTypeToSuggestions($$[$0]);
          this.$ = { types: [ 'BOOLEAN' ], typeSet: true  };

          break;
        case 989: case 990: case 991: case 992:

          if (!$$[$0-2].typeSet) {
            parser.applyTypeToSuggestions($$[$0]);
            parser.addColRefIfExists($$[$0]);
          }
          this.$ = { types: [ 'BOOLEAN' ], suggestFilters: $$[$0-2].suggestFilters }

          break;
        case 993: case 995:

          parser.valueExpressionSuggest($$[$0-2], $$[$0-1]);
          parser.applyTypeToSuggestions($$[$0-2]);
          this.$ = { types: [ 'BOOLEAN' ], typeSet: true  };

          break;
        case 994:

          parser.valueExpressionSuggest($$[$0-2], $$[$0-1]);
          parser.applyTypeToSuggestions($$[$0-2]);
          this.$ = { types: [ 'BOOLEAN' ] , typeSet: true, endsWithLessThanOrEqual: true };

          break;
        case 996:

          parser.valueExpressionSuggest($$[$0-2], $$[$0-1]);
          parser.applyTypeToSuggestions($$[$0-2]);
          this.$ = { types: [ 'BOOLEAN' ], typeSet: true, endsWithLessThanOrEqual: $$[$0-1] === '<='  };

          break;
        case 997: case 998: case 999: case 1000:

          if (!$$[$0].typeSet) {
            parser.applyTypeToSuggestions($$[$0-2]);
            parser.addColRefIfExists($$[$0-2]);
          }
          this.$ = { types: [ 'BOOLEAN' ], suggestFilters: $$[$0].suggestFilters }

          break;
        case 1001:

          if ($$[$0].inValueEdit) {
            parser.valueExpressionSuggest($$[$0-3], $$[$0-2] + ' ' + $$[$0-1]);
            parser.applyTypeToSuggestions($$[$0-3]);
          }
          if ($$[$0].cursorAtStart) {
            parser.suggestKeywords(['SELECT']);
          }
          this.$ = { types: [ 'BOOLEAN' ], typeSet: true  };

          break;
        case 1002:

          if ($$[$0].inValueEdit) {
            parser.valueExpressionSuggest($$[$0-2], $$[$0-1]);
            parser.applyTypeToSuggestions($$[$0-2]);
          }
          if ($$[$0].cursorAtStart) {
            parser.suggestKeywords(['SELECT']);
          }
          this.$ = { types: [ 'BOOLEAN' ], typeSet: true  };

          break;
        case 1003: case 1004:
          this.$ = { types: [ 'BOOLEAN' ], suggestFilters: $$[$0-5].suggestFilters };
          break;
        case 1005: case 1006:
          this.$ = { types: [ 'BOOLEAN' ], suggestFilters: $$[$0-4].suggestFilters };
          break;
        case 1007:

          if ($$[$0-2].types[0] === $$[$0].types[0] && !$$[$0-5].typeSet) {
            parser.applyTypeToSuggestions($$[$0-2]);
          }
          this.$ = { types: [ 'BOOLEAN' ], suggestFilters: $$[$0-5].suggestFilters };

          break;
        case 1008:

          if ($$[$0-5].types[0] === $$[$0].types[0] && !$$[$0-2].typeSet) {
            parser.applyTypeToSuggestions($$[$0-5]);
          }
          this.$ = { types: [ 'BOOLEAN' ], suggestFilters: $$[$0-2].suggestFilters };

          break;
        case 1009:

          if ($$[$0-5].types[0] === $$[$0-2].types[0] && !$$[$0].typeSet) {
            parser.applyTypeToSuggestions($$[$0-5]);
          }
          this.$ = { types: [ 'BOOLEAN' ], suggestFilters: $$[$0].suggestFilters };

          break;
        case 1010:

          parser.valueExpressionSuggest($$[$0-5], $$[$0-1]);
          this.$ = { types: [ 'BOOLEAN' ], typeSet: true  };

          break;
        case 1011: case 1017:

          parser.suggestValueExpressionKeywords($$[$0-1], ['AND']);
          this.$ = { types: [ 'BOOLEAN' ] };

          break;
        case 1012:

          parser.valueExpressionSuggest($$[$0-3], $$[$0-2] + ' ' + $$[$0-1]);
          this.$ = { types: [ 'BOOLEAN' ], typeSet: true  };

          break;
        case 1013:

          if ($$[$0-4].types[0] === $$[$0-2].types[0] && !$$[$0-4].typeSet) {
            parser.applyTypeToSuggestions($$[$0-4])
          }
          this.$ = { types: [ 'BOOLEAN' ], suggestFilters: $$[$0-4].suggestFilters };

          break;
        case 1014:

          if ($$[$0-4].types[0] === $$[$0-2].types[0] && !$$[$0-2].typeSet) {
            parser.applyTypeToSuggestions($$[$0-4])
          }
          this.$ = { types: [ 'BOOLEAN' ], suggestFilters: $$[$0-2].suggestFilters };

          break;
        case 1015:

          if ($$[$0-4].types[0] === $$[$0-2].types[0] && !$$[$0].typeSet) {
            parser.applyTypeToSuggestions($$[$0-4])
          }
          this.$ = { types: [ 'BOOLEAN' ], suggestFilters: $$[$0].suggestFilters };

          break;
        case 1016:

          parser.valueExpressionSuggest($$[$0-4], $$[$0-1]);
          parser.applyTypeToSuggestions($$[$0-4]);
          this.$ = { types: [ 'BOOLEAN' ], typeSet: true  };

          break;
        case 1018:

          parser.valueExpressionSuggest($$[$0-2], $$[$0-1]);
          parser.applyTypeToSuggestions($$[$0-2]);
          this.$ = { types: [ 'BOOLEAN' ], typeSet: true };

          break;
        case 1019: case 1021: case 1023: case 1025:

          parser.valueExpressionSuggest(undefined, $$[$0-1]);
          this.$ = { types: [ 'BOOLEAN' ], typeSet: true, suggestFilters: true };

          break;
        case 1020: case 1024:

          parser.addColRefIfExists($$[$0]);
          this.$ = { types: [ 'BOOLEAN' ], suggestFilters: $$[$0-2].suggestFilters }

          break;
        case 1022: case 1026:

          parser.addColRefIfExists($$[$0-2]);
          this.$ = { types: [ 'BOOLEAN' ], suggestFilters: $$[$0].suggestFilters }

          break;
        case 1027: case 1028:

          parser.valueExpressionSuggest(undefined, $$[$0-1]);
          parser.applyTypeToSuggestions({ types: [ 'NUMBER' ] });
          this.$ = { types: [ 'NUMBER' ], typeSet: true };

          break;
        case 1029: case 1030: case 1031:

          if (!$$[$0-2].typeSet) {
            parser.applyTypeToSuggestions({ types: ['NUMBER'] });
            parser.addColRefIfExists($$[$0]);
          }
          this.$ = { types: [ 'NUMBER' ], suggestFilters: $$[$0-2].suggestFilters }

          break;
        case 1032: case 1033: case 1034:

          parser.valueExpressionSuggest(undefined, $$[$0-1]);
          parser.applyTypeToSuggestions({ types: ['NUMBER'] });
          this.$ = { types: [ 'NUMBER' ], typeSet: true };

          break;
        case 1035: case 1036: case 1037:

          if (!$$[$0].typeSet) {
            parser.applyTypeToSuggestions({ types: ['NUMBER'] });
            parser.addColRefIfExists($$[$0-2]);
          }
          this.$ = { types: [ 'NUMBER' ], suggestFilters: $$[$0].suggestFilters };

          break;
        case 1038:
          this.$ = { types: [ 'BOOLEAN' ], suggestFilters: $$[$0-1].suggestFilters };
          break;
        case 1039:
          this.$ = { types: [ 'BOOLEAN' ], suggestFilters: $$[$0-2].suggestFilters };
          break;
        case 1042:

          parser.valueExpressionSuggest(undefined, $$[$0]);
          parser.applyTypeToSuggestions({ types: [ 'STRING' ] });
          this.$ = { types: [ 'BOOLEAN' ], typeSet: true };

          break;
        case 1043:

          parser.valueExpressionSuggest(undefined, $$[$0-1] + ' ' + $$[$0]);
          parser.applyTypeToSuggestions({ types: [ 'STRING' ] });
          this.$ = { types: [ 'BOOLEAN' ], typeSet: true };

          break;
        case 1045:

          parser.valueExpressionSuggest();
          parser.suggestKeywords(['WHEN']);
          this.$ = { types: [ 'T' ], typeSet: true };

          break;
        case 1047:

          parser.suggestValueExpressionKeywords($$[$0-2], ['WHEN']);
          this.$ = { types: [ 'T' ], typeSet: true };

          break;
        case 1048:

          this.$ = $$[$0];
          this.$.suggestFilters = $$[$0-1].suggestFilters;

          break;
        case 1049:
          this.$ = { types: [ 'T' ], suggestFilters: $$[$0-1].suggestFilters };
          break;
        case 1051: case 1053:

          $$[$0].position = 1;

          break;
        case 1052:

          $$[$0].position = $$[$0-2].position + 1;
          this.$ = $$[$0];

          break;
        case 1054:

          $$[$0-2].position += 1;

          break;
        case 1055:

          $$[$0-2].position = 1;

          break;
        case 1056:

          $$[$0-4].position += 1;

          break;
        case 1057:

          parser.valueExpressionSuggest();
          $$[$0-2].position += 1;

          break;
        case 1058:

          parser.valueExpressionSuggest();
          $$[$0-4].position += 1;

          break;
        case 1059:

          parser.suggestValueExpressionKeywords($$[$0-3]);

          break;
        case 1060: case 1061:

          parser.valueExpressionSuggest();
          this.$ = { cursorAtStart : true, position: 1 };

          break;
        case 1062: case 1063:

          parser.valueExpressionSuggest();
          this.$ = { position: 2 };

          break;
        case 1066:

          var lastLoc = parser.yy.locations[parser.yy.locations.length - 1];
          if (lastLoc.type !== 'variable') {
            lastLoc.type = 'column';
          }
          // used for function references with db prefix
          var firstLoc = parser.yy.locations[parser.yy.locations.length - $$[$0].length];
          this.$ = { chain: $$[$0], firstLoc: firstLoc, lastLoc: lastLoc }

          break;
        case 1073:

          parser.suggestValues($$[$0]);

          break;
        case 1074:
          this.$ = { types: [ 'NUMBER' ], text: $$[$0] };
          break;
        case 1080: case 1082: case 1083:
          this.$ = $$[$0-1] + $$[$0];
          break;
        case 1081: case 1084:
          this.$ = $$[$0-2] + $$[$0-1] + $$[$0];
          break;
        case 1085:
          this.$ = $$[$0-3] + $$[$0-2] + $$[$0-1] + $$[$0];
          break;
        case 1086:

          if (/\$\{[^}]*\}/.test($$[$0])) {
            parser.addVariableLocation(_$[$0], $$[$0]);
            this.$ = { types: [ 'STRING' ], columnReference: [{ name: $$[$0] }], text: "'" + $$[$0] + "'" }
          } else {
            this.$ = { types: [ 'STRING' ] }
          }

          break;
        case 1087:

          if (/\$\{[^}]*\}/.test($$[$0])) {
            parser.addVariableLocation(_$[$0], $$[$0]);
            this.$ = { types: [ 'STRING' ], columnReference: [{ name: $$[$0] }], text: '"' + $$[$0] + '"' }
          } else {
            this.$ = { types: [ 'STRING' ], text: '"' + $$[$0] + '"' }
          }

          break;
        case 1088:
          this.$ = { types: [ 'BOOLEAN' ], text: $$[$0] };
          break;
        case 1089:

          this.$ = { partialQuote: '\'', missingEndQuote: parser.yy.missingEndQuote };

          break;
        case 1090:

          this.$ = { partialQuote: '"', missingEndQuote: parser.yy.missingEndQuote };

          break;
        case 1097:

          this.$ = $$[$0];

          if (parser.yy.latestTablePrimaries.length > 0) {
            var idx = parser.yy.latestTablePrimaries.length - 1;
            var tables = [];
            do {
              var tablePrimary = parser.yy.latestTablePrimaries[idx];
              if (!tablePrimary.subQueryAlias) {
                tables.unshift(tablePrimary.alias ? { identifierChain: tablePrimary.identifierChain, alias: tablePrimary.alias } : { identifierChain: tablePrimary.identifierChain })
              }
              idx--;
            } while (idx >= 0 && tablePrimary.join && !tablePrimary.subQueryAlias)

            if (tables.length > 0) {
              this.$.suggestJoins = {
                prependJoin: true,
                tables: tables
              };
            }
          }

          break;
        case 1104:

          this.$ = {
            primary: $$[$0-1]
          }
          if ($$[$0-1].identifierChain) {
            if ($$[$0]) {
              $$[$0-1].alias = $$[$0].alias
              parser.addTableAliasLocation($$[$0].location, $$[$0].alias, $$[$0-1].identifierChain);
            }
            parser.addTablePrimary($$[$0-1]);
          }

          var keywords = [];
          if (!$$[$0]) {
            keywords = ['AS'];
          } else if ($$[$0].suggestKeywords) {
            keywords = $$[$0].suggestKeywords;
          }
          if (keywords.length > 0) {
            this.$.suggestKeywords = keywords;
          }

          break;
        case 1105:

          this.$ = {
            primary: $$[$0-1]
          };

          if ($$[$0]) {
            this.$.primary.alias = $$[$0].alias;
            parser.addTablePrimary({ subQueryAlias: $$[$0].alias });
            parser.addSubqueryAliasLocation($$[$0].location, $$[$0].alias, $$[$0-1].identifierChain);
          }

          var keywords = [];
          if (!$$[$0]) {
            keywords = ['AS'];
          }
          if (keywords.length > 0) {
            this.$.suggestKeywords = keywords;
          }

          break;
        case 1106:

          if ($$[$0]) {
            parser.addTableAliasLocation($$[$0].location, $$[$0].alias, $$[$0-1].identifierChain);
          }

          break;
        case 1107:

          if ($$[$0]) {
            parser.addTablePrimary({ subQueryAlias: $$[$0].alias });
            parser.addSubqueryAliasLocation($$[$0].location, $$[$0].alias);
          }

          break;
        case 1117:

          parser.pushQueryState();

          break;
        case 1118:

          parser.popQueryState();

          break;
        case 1120:

          if ($$[$0-1]) {
            $$[$0-2].alias = $$[$0-1].alias;
            parser.addTablePrimary({ subQueryAlias: $$[$0-1].alias });
            parser.addSubqueryAliasLocation($$[$0-1].location, $$[$0-1].alias, $$[$0-2].identifierChain);
          }
          this.$ = $$[$0-2];

          break;
        case 1123:

          var subQuery = parser.getSubQuery($$[$0]);
          subQuery.columns.forEach(function (column) {
            parser.expandIdentifierChain({ wrapper: column });
            delete column.linked;
          });
          parser.popQueryState(subQuery);
          this.$ = subQuery;

          break;
        case 1140: case 1141: case 1142: case 1143:
          this.$ = { alias: $$[$0], location: _$[$0] };
          break;
        case 1150: case 1151:

          if (parser.yy.result.suggestFunctions) {
            parser.suggestAggregateFunctions();
          }

          break;
        case 1152:

          if (!$$[$0-2] && !$$[$0-1]) {
            parser.suggestKeywords([{ value: 'PARTITION BY', weight: 2 }, { value: 'ORDER BY', weight: 1 }]);
          } else if (!$$[$0-2]) {
            parser.suggestKeywords(['PARTITION BY']);
          }

          break;
        case 1153:

          if (!$$[$0-1]) {
            parser.suggestValueExpressionKeywords($$[$0-3], [{ value: 'ORDER BY', weight: 2 }]);
          } else {
            parser.suggestValueExpressionKeywords($$[$0-3]);
          }

          break;
        case 1162:

          // Only allowed in last order by
          delete parser.yy.result.suggestAnalyticFunctions;

          break;
        case 1163:

          var keywords = [];
          if ($$[$0-2].suggestKeywords) {
            keywords = parser.createWeightedKeywords($$[$0-2].suggestKeywords, 2);
          }
          if (!$$[$0]) {
            keywords = keywords.concat([{ value: 'RANGE BETWEEN', weight: 1 }, { value: 'ROWS BETWEEN', weight: 1 }]);
          }
          parser.suggestKeywords(keywords);

          break;
        case 1169:

          parser.suggestKeywords(['BETWEEN']);

          break;
        case 1170:

          if (!$$[$0-2] && !$$[$0-1]) {
            parser.suggestKeywords(['CURRENT ROW', 'UNBOUNDED PRECEDING']);
          } else if (!$$[$0-1]) {
            parser.suggestKeywords(['AND']);
          }

          break;
        case 1175:

          lexer.popState();

          break;
        case 1176:

          lexer.begin('hdfs');

          break;
        case 1178:

          parser.suggestHdfs({ path: $$[$0-3] });

          break;
        case 1179:

          parser.suggestHdfs({ path: $$[$0-2] });

          break;
        case 1180:

          parser.suggestHdfs({ path: $$[$0-1] });

          break;
        case 1181:

          parser.suggestHdfs({ path: '' });

          break;
        case 1182:

          parser.suggestHdfs({ path: '' });

          break;
        case 1188:

          parser.suggestKeywords(['PRECEDING']);

          break;
        case 1189: case 1194:

          parser.suggestKeywords(['ROW']);

          break;
        case 1193:

          parser.suggestKeywords(['CURRENT ROW', 'UNBOUNDED FOLLOWING']);

          break;
        case 1195:

          parser.suggestKeywords(['FOLLOWING']);

          break;
        case 1199:
          this.$ = { inValueEdit: true };
          break;
        case 1200:
          this.$ = { inValueEdit: true, cursorAtStart: true };
          break;
        case 1201: case 1202: case 1203:

          this.$ = { suggestKeywords: ['NOT'] }
          parser.extractExpressionText(this.$, $$[$0-1], $$[$0]);

          break;
        case 1207: case 1208: case 1209:

          parser.suggestFunctions({ types: [ 'STRING' ] });
          parser.suggestColumns({ types: [ 'STRING' ] });
          this.$ = { types: ['BOOLEAN'] }

          break;
        case 1210:

          this.$ = parser.findCaseType($$[$0-1])
          parser.extractExpressionText(this.$, $$[$0-1], $$[$0]);

          break;
        case 1211:

          $$[$0-3].caseTypes.push($$[$0-1]);
          this.$ = parser.findCaseType($$[$0-3]);
          parser.extractExpressionText(this.$, $$[$0-3], $$[$0-2], $$[$0-1], $$[$0]);

          break;
        case 1212:
          this.$ = parser.findCaseType($$[$0-1]);
          break;
        case 1213:

          parser.suggestValueExpressionKeywords($$[$0-1], ['END']);
          $$[$0-3].caseTypes.push($$[$0-1]);
          this.$ = parser.findCaseType($$[$0-3]);

          break;
        case 1214:

          $$[$0-3].caseTypes.push($$[$0-1]);
          this.$ = parser.findCaseType($$[$0-3]);

          break;
        case 1215:
          this.$ = parser.findCaseType($$[$0-2]);
          break;
        case 1216:

          if ($$[$0].toLowerCase() !== 'end') {
            parser.suggestValueExpressionKeywords($$[$0-3], [{ value: 'END', weight: 3 }, { value: 'ELSE', weight: 2 }, { value: 'WHEN', weight: 1 }]);
          } else {
            parser.suggestValueExpressionKeywords($$[$0-3], [{ value: 'ELSE', weight: 2 }, { value: 'WHEN', weight: 1 }]);
          }
          this.$ = parser.findCaseType($$[$0-3]);

          break;
        case 1217:

          if ($$[$0].toLowerCase() !== 'end') {
            parser.suggestValueExpressionKeywords($$[$0-2], [{ value: 'END', weight: 3 }, { value: 'ELSE', weight: 2 }, { value: 'WHEN', weight: 1 }]);
          } else {
            parser.suggestValueExpressionKeywords($$[$0-2], [{ value: 'ELSE', weight: 2 }, { value: 'WHEN', weight: 1 }]);
          }
          this.$ = parser.findCaseType($$[$0-2]);

          break;
        case 1218:

          $$[$0-3].caseTypes.push($$[$0-1]);
          this.$ = parser.findCaseType($$[$0-3]);
          this.$.suggestFilters = $$[$0-1].suggestFilters

          break;
        case 1219:

          parser.valueExpressionSuggest();
          this.$ = parser.findCaseType($$[$0-3]);

          break;
        case 1220:

          parser.valueExpressionSuggest();
          this.$ = { types: [ 'T' ], typeSet: true };

          break;
        case 1221:

          parser.valueExpressionSuggest();
          parser.suggestKeywords(['WHEN']);
          this.$ = $$[$0-1];

          break;
        case 1222:

          parser.valueExpressionSuggest();
          parser.suggestKeywords(['WHEN']);
          this.$ = { types: [ 'T' ] };

          break;
        case 1225:

          this.$ = { caseTypes: [ $$[$0] ], lastType: $$[$0] }
          parser.extractExpressionText(this.$, $$[$0]);

          break;
        case 1226:

          $$[$0-1].caseTypes.push($$[$0]);
          this.$ = { caseTypes: $$[$0-1].caseTypes, lastType: $$[$0] };
          parser.extractExpressionText(this.$, $$[$0-1], $$[$0]);

          break;
        case 1230:

          parser.suggestValueExpressionKeywords($$[$0-2], ['WHEN']);

          break;
        case 1232:

          this.$ = $$[$0]
          parser.extractExpressionText(this.$, $$[$0-3], $$[$0-2], $$[$0-1], $$[$0]);

          break;
        case 1233:
          this.$ = { caseTypes: [{ types: ['T'] }], suggestFilters: $$[$0].suggestFilters };
          break;
        case 1234:
          this.$ = { caseTypes: [{ types: ['T'] }], suggestFilters: $$[$0-1].suggestFilters };
          break;
        case 1235:
          this.$ = { caseTypes: [$$[$0]], suggestFilters: $$[$0-2].suggestFilters };
          break;
        case 1236: case 1237:
          this.$ = { caseTypes: [$$[$0]], suggestFilters: $$[$0].suggestFilters };
          break;
        case 1238:

          parser.suggestKeywords(['WHEN']);
          this.$ = { caseTypes: [{ types: ['T'] }] };

          break;
        case 1239:

          parser.suggestKeywords(['WHEN']);
          this.$ = { caseTypes: [$$[$0]] };

          break;
        case 1240:

          parser.valueExpressionSuggest();
          parser.suggestKeywords(['WHEN']);
          this.$ = { caseTypes: [{ types: ['T'] }] };

          break;
        case 1241:

          parser.valueExpressionSuggest();
          parser.suggestKeywords(['WHEN']);
          this.$ = { caseTypes: [{ types: ['T'] }] };

          break;
        case 1242: case 1244:

          parser.valueExpressionSuggest();
          this.$ = { caseTypes: [{ types: ['T'] }], suggestFilters: true };

          break;
        case 1243:

          parser.valueExpressionSuggest();
          parser.suggestKeywords(['THEN']);
          this.$ = { caseTypes: [{ types: ['T'] }], suggestFilters: true };

          break;
        case 1245:

          parser.valueExpressionSuggest();
          this.$ = { caseTypes: [$$[$0]], suggestFilters: true };

          break;
        case 1246:

          parser.suggestValueExpressionKeywords($$[$0-1], ['THEN']);
          this.$ = { caseTypes: [{ types: ['T'] }] };

          break;
        case 1247:

          parser.suggestValueExpressionKeywords($$[$0-2], ['THEN']);
          this.$ = { caseTypes: [{ types: ['T'] }] };

          break;
        case 1248: case 1249: case 1250: case 1251:

          parser.valueExpressionSuggest();
          this.$ = { caseTypes: [{ types: ['T'] }] };

          break;
      }
    },
    table: importedTable,
    defaultActions: {9:[2,686],10:[2,687],11:[2,688],12:[2,689],13:[2,690],14:[2,691],15:[2,692],16:[2,693],17:[2,694],18:[2,695],19:[2,696],20:[2,697],21:[2,698],22:[2,699],23:[2,700],24:[2,701],25:[2,702],26:[2,703],27:[2,704],28:[2,705],29:[2,706],30:[2,707],31:[2,708],32:[2,709],33:[2,710],34:[2,711],35:[2,712],36:[2,713],37:[2,714],38:[2,715],39:[2,716],40:[2,717],41:[2,718],42:[2,719],43:[2,720],44:[2,721],45:[2,722],46:[2,723],47:[2,724],48:[2,725],49:[2,726],50:[2,727],51:[2,728],52:[2,729],53:[2,730],54:[2,731],55:[2,732],56:[2,733],57:[2,734],58:[2,735],59:[2,736],60:[2,737],61:[2,738],62:[2,739],63:[2,740],64:[2,741],65:[2,742],66:[2,743],67:[2,744],68:[2,745],69:[2,746],70:[2,747],71:[2,748],72:[2,749],73:[2,750],74:[2,751],75:[2,752],76:[2,753],77:[2,754],78:[2,755],79:[2,756],80:[2,757],81:[2,758],82:[2,759],83:[2,760],84:[2,761],85:[2,762],86:[2,763],87:[2,764],88:[2,765],89:[2,766],90:[2,767],91:[2,768],92:[2,769],94:[2,771],95:[2,772],96:[2,773],97:[2,774],98:[2,775],99:[2,776],100:[2,777],101:[2,778],102:[2,779],103:[2,780],104:[2,781],105:[2,782],106:[2,783],107:[2,784],108:[2,785],109:[2,786],110:[2,787],111:[2,788],112:[2,789],113:[2,790],114:[2,791],115:[2,792],116:[2,793],171:[2,670],173:[2,671],352:[2,555],353:[2,556],354:[2,557],355:[2,558],388:[2,531],389:[2,532],390:[2,533],391:[2,534],392:[2,535],393:[2,536],394:[2,537],395:[2,538],701:[2,63],703:[2,49],850:[2,660],1371:[2,661],1580:[2,657],1793:[2,662],1795:[2,665]},
    parseError: function parseError (str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
      }
    },
    parse: function parse (input) {
      var self = this,
        stack = [0],
        tstack = [], // token stack
        vstack = [null], // semantic value stack
        lstack = [], // location stack
        table = this.table,
        yytext = '',
        yylineno = 0,
        yyleng = 0,
        recovering = 0,
        TERROR = 2,
        EOF = 1;

      var args = lstack.slice.call(arguments, 1);

      //this.reductionCount = this.shiftCount = 0;

      var lexer = Object.create(this.lexer);
      var sharedState = { yy: {} };
      // copy state
      for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
          sharedState.yy[k] = this.yy[k];
        }
      }

      lexer.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer;
      sharedState.yy.parser = this;
      if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
      }
      var yyloc = lexer.yylloc;
      lstack.push(yyloc);

      var ranges = lexer.options && lexer.options.ranges;

      if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }

      function popStack (n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
      }

      _token_stack:
        var lex = function () {
          var token;
          token = lexer.lex() || EOF;
          // if token isn't its numeric value, convert
          if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
          }
          return token;
        }

      var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
      while (true) {
        // retreive state number from top of stack
        state = stack[stack.length - 1];

        // use default actions if available
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol === null || typeof symbol == 'undefined') {
            symbol = lex();
          }
          // read action for current state and first input
          action = table[state] && table[state][symbol];
        }

        _handle_error:
          // handle parse error
          if (typeof action === 'undefined' || !action.length || !action[0]) {
            var error_rule_depth;
            var errStr = '';

            // Return the rule stack depth where the nearest error rule can be found.
            // Return FALSE when no error recovery rule was found.
            function locateNearestErrorRecoveryRule(state) {
              var stack_probe = stack.length - 1;
              var depth = 0;

              // try to recover from error
              for(;;) {
                // check for error recovery rule in this state
                if ((TERROR.toString()) in table[state]) {
                  return depth;
                }
                if (state === 0 || stack_probe < 2) {
                  return false; // No suitable error recovery rule available.
                }
                stack_probe -= 2; // popStack(1): [symbol, action]
                state = stack[stack_probe];
                ++depth;
              }
            }

            if (!recovering) {
              // first see if there's any chance at hitting an error recovery rule:
              error_rule_depth = locateNearestErrorRecoveryRule(state);

              // Report error
              expected = [];
              for (p in table[state]) {
                if (this.terminals_[p] && p > TERROR) {
                  expected.push("'"+this.terminals_[p]+"'");
                }
              }
              if (lexer.showPosition) {
                errStr = 'Parse error on line '+(yylineno+1)+":\n"+lexer.showPosition()+"\nExpecting "+expected.join(', ') + ", got '" + (this.terminals_[symbol] || symbol)+ "'";
              } else {
                errStr = 'Parse error on line '+(yylineno+1)+": Unexpected " +
                  (symbol == EOF ? "end of input" :
                    ("'"+(this.terminals_[symbol] || symbol)+"'"));
              }
              this.parseError(errStr, {
                text: lexer.match,
                token: this.terminals_[symbol] || symbol,
                line: lexer.yylineno,
                loc: lexer.yylloc,
                ruleId: stack.slice(stack.length - 2, stack.length).join('_'),
                expected: expected,
                recoverable: (error_rule_depth !== false)
              });
            } else if (preErrorSymbol !== EOF) {
              error_rule_depth = locateNearestErrorRecoveryRule(state);
            }

            // just recovered from another error
            if (recovering == 3) {
              if (symbol === EOF || preErrorSymbol === EOF) {
                throw new Error(errStr || 'Parsing halted while starting to recover from another error.');
              }

              // discard current lookahead and grab another
              yyleng = lexer.yyleng;
              yytext = lexer.yytext;
              yylineno = lexer.yylineno;
              yyloc = lexer.yylloc;
              symbol = lex();
            }

            // try to recover from error
            if (error_rule_depth === false) {
              throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');
            }
            popStack(error_rule_depth);

            preErrorSymbol = (symbol == TERROR ? null : symbol); // save the lookahead token
            symbol = TERROR;         // insert generic error symbol as new lookahead
            state = stack[stack.length-1];
            action = table[state] && table[state][TERROR];
            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
          }

        // this shouldn't happen, unless resolve defaults are off
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);
        }

        switch (action[0]) {
          case 1: // shift
            //this.shiftCount++;

            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]); // push state
            symbol = null;
            if (!preErrorSymbol) { // normal execution/no error
              yyleng = lexer.yyleng;
              yytext = lexer.yytext;
              yylineno = lexer.yylineno;
              yyloc = lexer.yylloc;
              if (recovering > 0) {
                recovering--;
              }
            } else {
              // error just occurred, resume old lookahead f/ before error
              symbol = preErrorSymbol;
              preErrorSymbol = null;
            }
            break;

          case 2:
            // reduce
            //this.reductionCount++;

            len = this.productions_[action[1]][1];

            // perform semantic action
            yyval.$ = vstack[vstack.length-len]; // default to $$ = $1
            // default location, uses first token for firsts, last for lasts
            yyval._$ = {
              first_line: lstack[lstack.length-(len||1)].first_line,
              last_line: lstack[lstack.length-1].last_line,
              first_column: lstack[lstack.length-(len||1)].first_column,
              last_column: lstack[lstack.length-1].last_column
            };
            if (ranges) {
              yyval._$.range = [lstack[lstack.length-(len||1)].range[0], lstack[lstack.length-1].range[1]];
            }
            r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));

            if (typeof r !== 'undefined') {
              return r;
            }

            // pop off stack
            if (len) {
              stack = stack.slice(0,-1*len*2);
              vstack = vstack.slice(0, -1*len);
              lstack = lstack.slice(0, -1*len);
            }

            stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            // goto new state = table[STATE][NONTERMINAL]
            newState = table[stack[stack.length-2]][stack[stack.length-1]];
            stack.push(newState);
            break;

          case 3:
            // accept
            return true;
        }

      }

      return true;
    }};


  SqlParseSupport.initSqlParser(parser);/* generated by jison-lex 0.3.4 */
  var lexer = (function(){
    var lexer = ({

      EOF:1,

      parseError:function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },

// resets the lexer, sets new input
      setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
      },

// consumes and returns one char from the input
      input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
      },

// unshifts one char (or a string) into the input
      unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ?
            (lines.length === oldLines.length ? this.yylloc.first_column : 0)
            + oldLines[oldLines.length - lines.length].length - lines[0].length :
            this.yylloc.first_column - len
        };

        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },

// When called from action, caches matched text and appends it on next action
      more:function () {
        this._more = true;
        return this;
      },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject:function () {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });

        }
        return this;
      },

// retain first n characters of the match
      less:function (n) {
        this.unput(this.match.slice(n));
      },

// displays already matched input, i.e. for error messages
      pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
      },

// displays upcoming input, i.e. for error messages
      upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
          next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
      },

// displays the character position where the lexing error occurred, i.e. for error messages
      showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
      },

// test the lexed token: return FALSE when not a match, otherwise return token
      test_match:function(match, indexed_rule) {
        var token,
          lines,
          backup;

        if (this.options.backtrack_lexer) {
          // save context
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ?
            lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
            this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token) {
          return token;
        } else if (this._backtrack) {
          // recover context
          for (var k in backup) {
            this[k] = backup[k];
          }
          return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
      },

// return next match in input
      next:function () {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }

        var token,
          match,
          tempMatch,
          index;
        if (!this._more) {
          this.yytext = '';
          this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index = i;
            if (this.options.backtrack_lexer) {
              token = this.test_match(tempMatch, rules[i]);
              if (token !== false) {
                return token;
              } else if (this._backtrack) {
                match = false;
                continue; // rule action called reject() implying a rule MISmatch.
              } else {
                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token = this.test_match(match, rules[index]);
          if (token !== false) {
            return token;
          }
          // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },

// return next match that has a token
      lex:function lex () {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin:function begin (condition) {
        this.conditionStack.push(condition);
      },

// pop the previously active lexer condition state off the condition stack
      popState:function popState () {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },

// produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules:function _currentRules () {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState:function topState (n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },

// alias for begin(condition)
      pushState:function pushState (condition) {
        this.begin(condition);
      },

// return the number of states currently on the stack
      stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
      },
      options: {"case-insensitive":true,"flex":true},
      performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
        var YYSTATE=YY_START;
        switch($avoiding_name_collisions) {
          case 0: /* skip whitespace */
            break;
          case 1: /* skip comments */
            break;
          case 2: /* skip comments */
            break;
          case 3: parser.yy.partialCursor = false; parser.yy.cursorFound = yy_.yylloc; return 5;
            break;
          case 4: parser.yy.partialCursor = true; parser.yy.cursorFound = yy_.yylloc; return 399;
            break;
          case 5: this.popState(); return 445;
            break;
          case 6: return 30;
            break;
          case 7: parser.determineCase(yy_.yytext); parser.addStatementTypeLocation('ALTER', yy_.yylloc, yy.lexer.upcomingInput()); return 4;
            break;
          case 8: return 362;
            break;
          case 9: return 43;
            break;
          case 10: return 239;
            break;
          case 11: this.begin('between'); return 365;
            break;
          case 12: return 366;
            break;
          case 13: return 367;
            break;
          case 14: return 126;
            break;
          case 15: return 411;
            break;
          case 16: return 368;
            break;
          case 17: return 369;
            break;
          case 18: return 50;
            break;
          case 19: parser.determineCase(yy_.yytext); return 8;
            break;
          case 20: return 214;
            break;
          case 21: return 370;
            break;
          case 22: return 371;
            break;
          case 23: return 372;
            break;
          case 24: return 240;
            break;
          case 25: return 250;
            break;
          case 26: return 363;
            break;
          case 27: return 373;
            break;
          case 28: parser.determineCase(yy_.yytext); parser.addStatementTypeLocation('DROP', yy_.yylloc, yy.lexer.upcomingInput()); return 12;
            break;
          case 29: return 374;
            break;
          case 30: return 375;
            break;
          case 31: parser.yy.correlatedSubQuery = true; return 376;
            break;
          case 32: return 273;
            break;
          case 33: return 377;
            break;
          case 34: return 378;
            break;
          case 35: parser.determineCase(yy_.yytext); return 182;
            break;
          case 36: return 216;
            break;
          case 37: return 190;
            break;
          case 38: return 201;
            break;
          case 39: return 309;
            break;
          case 40: return 380;
            break;
          case 41: return 218;
            break;
          case 42: return 162;
            break;
          case 43: return 381;
            break;
          case 44: return 163;
            break;
          case 45: return 382;
            break;
          case 46: return 215;
            break;
          case 47: return 219;
            break;
          case 48: return 77;
            break;
          case 49: return 226;
            break;
          case 50: return 95;
            break;
          case 51: return 96;
            break;
          case 52: return 222;
            break;
          case 53: return 355;
            break;
          case 54: return 383;
            break;
          case 55: return 232;
            break;
          case 56: return 217;
            break;
          case 57: return 125;
            break;
          case 58: return 384;
            break;
          case 59: return 154;
            break;
          case 60: return 129;
            break;
          case 61: return 385;
            break;
          case 62: return 221;
            break;
          case 63: return 386;
            break;
          case 64: return 387;
            break;
          case 65: return 63;
            break;
          case 66: return 388;
            break;
          case 67: return 389;
            break;
          case 68: parser.determineCase(yy_.yytext); parser.addStatementTypeLocation('SELECT', yy_.yylloc); return 241;
            break;
          case 69: return 220;
            break;
          case 70: parser.determineCase(yy_.yytext); parser.addStatementTypeLocation('SET', yy_.yylloc); return 16;
            break;
          case 71: parser.determineCase(yy_.yytext); parser.addStatementTypeLocation('SHOW', yy_.yylloc); return 'SHOW';
            break;
          case 72: return 390;
            break;
          case 73: return 391;
            break;
          case 74: return 39;
            break;
          case 75: return 392;
            break;
          case 76: return 393;
            break;
          case 77: return 394;
            break;
          case 78: return 'TO';
            break;
          case 79: return 272;
            break;
          case 80: parser.determineCase(yy_.yytext); parser.addStatementTypeLocation('TRUNCATE', yy_.yylloc, yy.lexer.upcomingInput()); return 274;
            break;
          case 81: return 500;
            break;
          case 82: return 265;
            break;
          case 83: parser.determineCase(yy_.yytext); return 324;
            break;
          case 84: parser.determineCase(yy_.yytext); parser.addStatementTypeLocation('USE', yy_.yylloc); return 340;
            break;
          case 85: return 140;
            break;
          case 86: return 397;
            break;
          case 87: return 47;
            break;
          case 88: return 398;
            break;
          case 89: return 267;
            break;
          case 90: parser.determineCase(yy_.yytext); parser.addStatementTypeLocation('WITH', yy_.yylloc); return 174;
            break;
          case 91: return 321;
            break;
          case 92: return 63;
            break;
          case 93: yy.lexer.unput('('); yy_.yytext = 'avg'; parser.addFunctionLocation(yy_.yylloc, yy_.yytext); return 297;
            break;
          case 94: yy.lexer.unput('('); yy_.yytext = 'cast'; parser.addFunctionLocation(yy_.yylloc, yy_.yytext); return 310;
            break;
          case 95: yy.lexer.unput('('); yy_.yytext = 'count'; parser.addFunctionLocation(yy_.yylloc, yy_.yytext); return 305;
            break;
          case 96: yy.lexer.unput('('); yy_.yytext = 'max'; parser.addFunctionLocation(yy_.yylloc, yy_.yytext); return 298;
            break;
          case 97: yy.lexer.unput('('); yy_.yytext = 'min'; parser.addFunctionLocation(yy_.yylloc, yy_.yytext); return 299;
            break;
          case 98: yy.lexer.unput('('); yy_.yytext = 'stddev_pop'; parser.addFunctionLocation(yy_.yylloc, yy_.yytext); return 300;
            break;
          case 99: yy.lexer.unput('('); yy_.yytext = 'stddev_samp'; parser.addFunctionLocation(yy_.yylloc, yy_.yytext); return 301;
            break;
          case 100: yy.lexer.unput('('); yy_.yytext = 'sum'; parser.addFunctionLocation(yy_.yylloc, yy_.yytext); return 306;
            break;
          case 101: yy.lexer.unput('('); yy_.yytext = 'var_pop'; parser.addFunctionLocation(yy_.yylloc, yy_.yytext); return 302;
            break;
          case 102: yy.lexer.unput('('); yy_.yytext = 'var_samp'; parser.addFunctionLocation(yy_.yylloc, yy_.yytext); return 303;
            break;
          case 103: yy.lexer.unput('('); yy_.yytext = 'variance'; parser.addFunctionLocation(yy_.yylloc, yy_.yytext); return 304;
            break;
          case 104: yy.lexer.unput('('); yy_.yytext = 'cume_dist'; parser.addFunctionLocation(yy_.yylloc, yy_.yytext); return 307;
            break;
          case 105: yy.lexer.unput('('); yy_.yytext = 'dense_rank'; parser.addFunctionLocation(yy_.yylloc, yy_.yytext); return 307;
            break;
          case 106: yy.lexer.unput('('); yy_.yytext = 'first_value'; parser.addFunctionLocation(yy_.yylloc, yy_.yytext); return 307;
            break;
          case 107: yy.lexer.unput('('); yy_.yytext = 'lag'; parser.addFunctionLocation(yy_.yylloc, yy_.yytext); return 307;
            break;
          case 108: yy.lexer.unput('('); yy_.yytext = 'last_value'; parser.addFunctionLocation(yy_.yylloc, yy_.yytext); return 307;
            break;
          case 109: yy.lexer.unput('('); yy_.yytext = 'lead'; parser.addFunctionLocation(yy_.yylloc, yy_.yytext); return 307;
            break;
          case 110: yy.lexer.unput('('); yy_.yytext = 'rank'; parser.addFunctionLocation(yy_.yylloc, yy_.yytext); return 307;
            break;
          case 111: yy.lexer.unput('('); yy_.yytext = 'row_number'; parser.addFunctionLocation(yy_.yylloc, yy_.yytext); return 307;
            break;
          case 112: return 395;
            break;
          case 113: return 395;
            break;
          case 114: return 396;
            break;
          case 115: return 356;
            break;
          case 116: parser.yy.cursorFound = true; return 5;
            break;
          case 117: parser.yy.cursorFound = true; return 399;
            break;
          case 118: return 379;
            break;
          case 119: parser.addFileLocation(yy_.yylloc, yy_.yytext); return 505;
            break;
          case 120: this.popState(); return 506;
            break;
          case 121: return 351;
            break;
          case 122: return 362;
            break;
          case 123: return 383;
            break;
          case 124: return 32;
            break;
          case 125: return 108;
            break;
          case 126: return 109;
            break;
          case 127: return 142;
            break;
          case 128: return 142;
            break;
          case 129: return 142;
            break;
          case 130: return 142;
            break;
          case 131: return 142;
            break;
          case 132: return 358;
            break;
          case 133: return 256;
            break;
          case 134: return 363;
            break;
          case 135: return 363;
            break;
          case 136: return 363;
            break;
          case 137: return 363;
            break;
          case 138: return 363;
            break;
          case 139: return 363;
            break;
          case 140: return 85;
            break;
          case 141: return 270;
            break;
          case 142: return 120;
            break;
          case 143: return 344;
            break;
          case 144: return 361;
            break;
          case 145: return 357;
            break;
          case 146: return 79;
            break;
          case 147: return 81;
            break;
          case 148: return 359;
            break;
          case 149: return 360;
            break;
          case 150: return 228;
            break;
          case 151: this.begin('backtickedValue'); return 364;
            break;
          case 152:
            if (parser.handleQuotedValueWithCursor(this, yy_.yytext, yy_.yylloc, '`')) {
              return 403;
            }
            return 56;

            break;
          case 153: this.popState(); return 364;
            break;
          case 154: this.begin('singleQuotedValue'); return 54;
            break;
          case 155:
            if (parser.handleQuotedValueWithCursor(this, yy_.yytext, yy_.yylloc, '\'')) {
              return 403;
            }
            return 56;

            break;
          case 156: this.popState(); return 54;
            break;
          case 157: this.begin('doubleQuotedValue'); return 55;
            break;
          case 158:
            if (parser.handleQuotedValueWithCursor(this, yy_.yytext, yy_.yylloc, '"')) {
              return 403;
            }
            return 56;

            break;
          case 159: this.popState(); return 55;
            break;
          case 160: return 351;
            break;
          case 161: /* To prevent console logging of unknown chars */
            break;
          case 162:
            break;
          case 163:
            break;
          case 164:
            break;
          case 165:
            break;
          case 166:
            break;
          case 167:console.log(yy_.yytext);
            break;
        }
      },
      rules: [/^(?:\s)/i,/^(?:--.*)/i,/^(?:[\/][*][^*]*[*]+([^\/*][^*]*[*]+)*[\/])/i,/^(?:\u2020)/i,/^(?:\u2021)/i,/^(?:AND)/i,/^(?:ALL)/i,/^(?:ALTER)/i,/^(?:AND)/i,/^(?:AS)/i,/^(?:ASC)/i,/^(?:BETWEEN)/i,/^(?:BIGINT)/i,/^(?:BOOLEAN)/i,/^(?:BY)/i,/^(?:CASCADE)/i,/^(?:CASE)/i,/^(?:CHAR)/i,/^(?:COMMENT)/i,/^(?:CREATE)/i,/^(?:CROSS)/i,/^(?:CURRENT)/i,/^(?:DATABASE)/i,/^(?:DECIMAL)/i,/^(?:DESC)/i,/^(?:DISTINCT)/i,/^(?:DIV)/i,/^(?:DOUBLE)/i,/^(?:DROP)/i,/^(?:ELSE)/i,/^(?:END)/i,/^(?:EXISTS)/i,/^(?:FALSE)/i,/^(?:FLOAT)/i,/^(?:FOLLOWING)/i,/^(?:FROM)/i,/^(?:FULL)/i,/^(?:GROUP)/i,/^(?:HAVING)/i,/^(?:IF)/i,/^(?:IN)/i,/^(?:INNER)/i,/^(?:INSERT)/i,/^(?:INT)/i,/^(?:INTO)/i,/^(?:IS)/i,/^(?:JOIN)/i,/^(?:LEFT)/i,/^(?:LIKE)/i,/^(?:LIMIT)/i,/^(?:NOT)/i,/^(?:NULL)/i,/^(?:ON)/i,/^(?:OPTION)/i,/^(?:OR)/i,/^(?:ORDER)/i,/^(?:OUTER)/i,/^(?:PARTITION)/i,/^(?:PRECEDING)/i,/^(?:PURGE)/i,/^(?:RANGE)/i,/^(?:REGEXP)/i,/^(?:RIGHT)/i,/^(?:ILIKE)/i,/^(?:ROW)/i,/^(?:ROLE)/i,/^(?:ROWS)/i,/^(?:SCHEMA)/i,/^(?:SELECT)/i,/^(?:SEMI)/i,/^(?:SET)/i,/^(?:SHOW)/i,/^(?:SMALLINT)/i,/^(?:STRING)/i,/^(?:TABLE)/i,/^(?:THEN)/i,/^(?:TIMESTAMP)/i,/^(?:TINYINT)/i,/^(?:TO)/i,/^(?:TRUE)/i,/^(?:TRUNCATE)/i,/^(?:UNBOUNDED)/i,/^(?:UNION)/i,/^(?:UPDATE)/i,/^(?:USE)/i,/^(?:VALUES)/i,/^(?:VARCHAR)/i,/^(?:VIEW)/i,/^(?:WHEN)/i,/^(?:WHERE)/i,/^(?:WITH)/i,/^(?:OVER)/i,/^(?:ROLE)/i,/^(?:AVG\s*\()/i,/^(?:CAST\s*\()/i,/^(?:COUNT\s*\()/i,/^(?:MAX\s*\()/i,/^(?:MIN\s*\()/i,/^(?:STDDEV_POP\s*\()/i,/^(?:STDDEV_SAMP\s*\()/i,/^(?:SUM\s*\()/i,/^(?:VAR_POP\s*\()/i,/^(?:VAR_SAMP\s*\()/i,/^(?:VARIANCE\s*\()/i,/^(?:CUME_DIST\s*\()/i,/^(?:DENSE_RANK\s*\()/i,/^(?:FIRST_VALUE\s*\()/i,/^(?:LAG\s*\()/i,/^(?:LAST_VALUE\s*\()/i,/^(?:LEAD\s*\()/i,/^(?:RANK\s*\()/i,/^(?:ROW_NUMBER\s*\()/i,/^(?:[0-9]+)/i,/^(?:[0-9]+(?:[YSL]|BD)?)/i,/^(?:[0-9]+E)/i,/^(?:[A-Za-z0-9_]+)/i,/^(?:\u2020)/i,/^(?:\u2021)/i,/^(?:\s+['"])/i,/^(?:[^'"\u2020\u2021]+)/i,/^(?:['"])/i,/^(?:$)/i,/^(?:&&)/i,/^(?:\|\|)/i,/^(?:=)/i,/^(?:<)/i,/^(?:>)/i,/^(?:!=)/i,/^(?:<=)/i,/^(?:>=)/i,/^(?:<>)/i,/^(?:<=>)/i,/^(?:-)/i,/^(?:\*)/i,/^(?:\+)/i,/^(?:\/)/i,/^(?:%)/i,/^(?:\|)/i,/^(?:\^)/i,/^(?:&)/i,/^(?:,)/i,/^(?:\.)/i,/^(?::)/i,/^(?:;)/i,/^(?:~)/i,/^(?:!)/i,/^(?:\()/i,/^(?:\))/i,/^(?:\[)/i,/^(?:\])/i,/^(?:\$\{[^}]*\})/i,/^(?:`)/i,/^(?:[^`]+)/i,/^(?:`)/i,/^(?:')/i,/^(?:(?:\\\\|\\[']|[^'])+)/i,/^(?:')/i,/^(?:")/i,/^(?:(?:\\\\|\\["]|[^"])+)/i,/^(?:")/i,/^(?:$)/i,/^(?:.)/i,/^(?:.)/i,/^(?:.)/i,/^(?:.)/i,/^(?:.)/i,/^(?:.)/i,/^(?:.)/i],
      conditions: {"hdfs":{"rules":[116,117,118,119,120,121,163],"inclusive":false},"doubleQuotedValue":{"rules":[158,159,166],"inclusive":false},"singleQuotedValue":{"rules":[155,156,165],"inclusive":false},"backtickedValue":{"rules":[152,153,164],"inclusive":false},"between":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,154,157,160,161,162,167],"inclusive":true},"INITIAL":{"rules":[0,1,2,3,4,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,154,157,160,161,167],"inclusive":true}}
    });
    return lexer;
  })();
  parser.lexer = lexer;
  function Parser () {
    this.yy = {};
  }
  Parser.prototype = parser;parser.Parser = Parser;
  return new Parser;
})();
export default genericAutocompleteParser;
